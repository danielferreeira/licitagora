[
  {
    "full_schema": "CREATE SCHEMA IF NOT EXISTS \"auth\";\n\nCREATE SCHEMA IF NOT EXISTS \"realtime\";\n\nCREATE SCHEMA IF NOT EXISTS \"vault\";\n\nCREATE SCHEMA IF NOT EXISTS \"graphql_public\";\n\nCREATE SCHEMA IF NOT EXISTS \"graphql\";\n\nCREATE SCHEMA IF NOT EXISTS \"public\";\n\nCREATE SCHEMA IF NOT EXISTS \"extensions\";\n\nCREATE SCHEMA IF NOT EXISTS \"storage\";\n\nCREATE TABLE \"public\".\"prazos\" (\"licitacao_id\" uuid, \"id\" uuid, \"tipo\" USER-DEFINED, \"data_prazo\" timestamp with time zone, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"titulo\" character varying, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"permissoes\" (\"id\" uuid, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"codigo\" character varying, \"nome\" character varying, \"descricao\" text);\n\nCREATE TABLE \"public\".\"documentos_licitacao\" (\"id\" uuid, \"licitacao_id\" uuid, \"tipo_documento_id\" uuid, \"data_validade\" timestamp with time zone, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"arquivo_url\" text, \"observacoes\" text, \"nome\" character varying);\n\nCREATE TABLE \"public\".\"permissoes_tipo_usuario\" (\"id\" uuid, \"tipo_usuario\" USER-DEFINED, \"permissao_id\" uuid, \"ativo\" boolean, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone);\n\nCREATE TABLE \"public\".\"permissoes_franquia\" (\"id\" uuid, \"franquia_id\" uuid, \"permissao_id\" uuid, \"ativo\" boolean, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone);\n\nCREATE TABLE \"public\".\"clientes\" (\"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"cnaes\" jsonb, \"franquia_id\" uuid, \"user_id\" uuid, \"matriz_id\" uuid, \"data_vinculo\" timestamp with time zone, \"id\" uuid, \"razao_social\" character varying, \"cnpj\" character varying, \"email\" character varying, \"telefone\" character varying, \"cep\" character varying, \"endereco\" character varying, \"numero\" character varying, \"bairro\" character varying, \"cidade\" character varying, \"estado\" character varying);\n\nCREATE TABLE \"public\".\"requisitos_documentacao\" (\"id\" uuid, \"licitacao_id\" uuid, \"atendido\" boolean, \"ordem\" integer, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"descricao\" text, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"requisitos_documentacao_backup\" (\"id\" uuid, \"licitacao_id\" uuid, \"status\" USER-DEFINED, \"atendido\" boolean, \"ordem\" integer, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"descricao\" text, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"perfis_usuario\" (\"id\" uuid, \"user_id\" uuid, \"tipo\" USER-DEFINED, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"telefone\" character varying, \"nome\" character varying);\n\nCREATE TABLE \"public\".\"health_check\" (\"id\" integer, \"last_check\" timestamp with time zone, \"details\" jsonb, \"status\" text);\n\nCREATE TABLE \"public\".\"licitacoes\" (\"id\" uuid, \"cliente_id\" uuid, \"modalidade\" USER-DEFINED, \"valor_estimado\" numeric, \"lucro_estimado\" numeric, \"data_abertura\" timestamp with time zone, \"data_fim\" timestamp with time zone, \"status\" USER-DEFINED, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"valor_final\" numeric, \"lucro_final\" numeric, \"foi_ganha\" boolean, \"data_fechamento\" timestamp with time zone, \"ramos_atividade\" ARRAY, \"numero\" character varying, \"orgao\" character varying, \"objeto\" text, \"motivo_perda\" text, \"descricao\" text, \"requisitos\" text, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"franquias\" (\"id\" uuid, \"user_id\" uuid, \"ativo\" boolean, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"ativa\" boolean, \"nome\" character varying, \"cnpj\" character varying, \"email\" character varying, \"telefone\" character varying, \"endereco\" character varying, \"cidade\" character varying, \"estado\" character varying, \"cep\" character varying, \"bairro\" character varying, \"numero\" character varying);\n\nCREATE TABLE \"public\".\"documentos_cliente\" (\"id\" uuid, \"cliente_id\" uuid, \"tipo_documento_id\" uuid, \"data_validade\" timestamp with time zone, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"nome\" character varying, \"arquivo_url\" text, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"licitacoes_cliente\" (\"id\" uuid, \"licitacao_id\" uuid, \"cliente_id\" uuid, \"franquia_id\" uuid, \"aceita\" boolean, \"data_vinculacao\" timestamp with time zone, \"data_resposta\" timestamp with time zone, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone, \"status\" character varying, \"observacoes\" text);\n\nCREATE TABLE \"public\".\"tipos_documentos\" (\"updated_at\" timestamp with time zone, \"id\" uuid, \"obrigatorio\" boolean, \"created_at\" timestamp with time zone, \"descricao\" text, \"nome\" character varying);\n\nCREATE TABLE \"public\".\"usuarios_view\" (\"email\" character varying);\n\nCREATE TABLE \"public\".\"permissoes_cliente\" (\"id\" uuid, \"cliente_id\" uuid, \"permissao_id\" uuid, \"ativo\" boolean, \"created_at\" timestamp with time zone, \"updated_at\" timestamp with time zone);\n\nCREATE SEQUENCE \"pgsodium\".\"key_key_id_seq\";\n\nCREATE SEQUENCE \"public\".\"health_check_id_seq\";\n\nCREATE SEQUENCE \"realtime\".\"subscription_id_seq\";\n\nCREATE SEQUENCE \"auth\".\"refresh_tokens_id_seq\";\n\nCREATE SEQUENCE \"graphql\".\"seq_schema_version\";\n\nCREATE VIEW \"public\".\"usuarios_view\" AS  SELECT users.email\n   FROM auth.users;;\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_saltgen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_saltgen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str(password bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kx_client_session_keys(client_pk bytea, client_sk bytea, server_pk bytea)\n RETURNS pgsodium.crypto_kx_session\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_client_session_keys$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kx_server_session_keys(server_pk bytea, server_sk bytea, client_pk bytea)\n RETURNS pgsodium.crypto_kx_session\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_server_session_keys$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_new_seed$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_new_seed$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.derive_key(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_derive$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.pgsodium_derive(key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT decode('pgsodium'::text, 'escape'::text))\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_derive$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.randombytes_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_new_seed$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_noncegen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_generichash_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_keypair()\n RETURNS pgsodium.crypto_kx_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kx_new_seed()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_new_seed$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kx_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_kx_keypair\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kx_seed_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_new_keypair()\n RETURNS pgsodium.crypto_box_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_new_keypair()\n RETURNS pgsodium.crypto_sign_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_new_keypair()\n RETURNS pgsodium.crypto_signcrypt_keypair\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_init()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_init$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update(state bytea, message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_update$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.randombytes_random()\n RETURNS integer\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_random$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_noncegen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_noncegen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretstream_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretstream_xchacha20poly1305_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_noncegen$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_cmp(text, text)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/pgsodium', $function$pgsodium_cmp$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(ciphertext bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.version()\n RETURNS text\n LANGUAGE sql\nAS $function$ SELECT extversion FROM pg_extension WHERE extname = 'pgsodium' $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_noncegen$function$\n\n\nCREATE OR REPLACE FUNCTION vault.secrets_encrypt_secret_secret()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n\t\tBEGIN\n\t\t        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(new.secret, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),\n\t\t\t\tnew.key_id::uuid,\n\t\t\t\tnew.nonce\n\t\t\t  ),\n\t\t\t\t'base64') END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t$function$\n\n\nCREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE sql\nAS $function$\n    INSERT INTO vault.secrets (secret, name, description, key_id)\n    VALUES (\n        new_secret,\n        new_name,\n        new_description,\n        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)\n    RETURNING id;\n    $function$\n\n\nCREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE sql\nAS $function$\n\tUPDATE vault.decrypted_secrets s\n    SET\n        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,\n        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,\n        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,\n        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE s.id = secret_id\n    $function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.has_mask(role regrole, source_name text)\n RETURNS boolean\n LANGUAGE sql\nAS $function$\n  SELECT EXISTS(\n    SELECT 1\n      FROM pg_shseclabel\n     WHERE  objoid = role\n       AND provider = 'pgsodium'\n       AND label ilike 'ACCESS%' || source_name || '%')\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.mask_columns(source_relid oid)\n RETURNS TABLE(attname name, key_id text, key_id_column text, associated_column text, nonce_column text, format_type text)\n LANGUAGE sql\nAS $function$\n  SELECT\n  a.attname,\n  m.key_id,\n  m.key_id_column,\n  m.associated_column,\n  m.nonce_column,\n  m.format_type\n  FROM pg_attribute a\n  LEFT JOIN  pgsodium.masking_rule m\n  ON m.attrelid = a.attrelid\n  AND m.attname = a.attname\n  WHERE  a.attrelid = source_relid\n  AND    a.attnum > 0 -- exclude ctid, cmin, cmax\n  AND    NOT a.attisdropped\n  ORDER BY a.attnum;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog'\nAS $function$\nDECLARE\n  body text;\n  source_name text;\n  view_name text;\n  rule pgsodium.masking_rule;\nBEGIN\n  SELECT DISTINCT(quote_ident(relname)) INTO STRICT view_name\n    FROM pg_class c, pg_seclabel sl\n   WHERE relid = c.oid\n     AND sl.classoid = c.tableoid\n     AND sl.objoid = c.oid;\n\n  source_name := relid::regclass;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS pgsodium_masks.%s;\n    CREATE VIEW pgsodium_masks.%s AS SELECT %s\n    FROM %s;\n    $c$,\n    view_name,\n    view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  body = format(\n    $c$\n    CREATE OR REPLACE FUNCTION pgsodium_masks.%s_encrypt_secret()\n      RETURNS TRIGGER\n      LANGUAGE plpgsql\n      AS $t$\n    BEGIN\n    %s;\n    RETURN new;\n    END;\n    $t$;\n\n    DROP TRIGGER IF EXISTS %s_encrypt_secret_trigger ON %s;\n\n    CREATE TRIGGER %s_encrypt_secret_trigger\n      BEFORE INSERT ON %s\n      FOR EACH ROW\n      EXECUTE FUNCTION pgsodium_masks.%s_encrypt_secret ();\n    $c$,\n    view_name,\n    pgsodium.encrypted_columns(relid),\n    view_name,\n    source_name,\n    view_name,\n    source_name,\n    view_name\n  );\n  if debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.create_key(key_type pgsodium.key_type DEFAULT 'aead-det'::pgsodium.key_type, name text DEFAULT NULL::text, raw_key bytea DEFAULT NULL::bytea, raw_key_nonce bytea DEFAULT NULL::bytea, parent_key uuid DEFAULT NULL::uuid, key_context bytea DEFAULT '\\x7067736f6469756d'::bytea, expires timestamp with time zone DEFAULT NULL::timestamp with time zone, associated_data text DEFAULT ''::text)\n RETURNS pgsodium.valid_key\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  new_key pgsodium.key;\n  valid_key pgsodium.valid_key;\nBEGIN\n  INSERT INTO pgsodium.key (key_id, key_context, key_type, raw_key,\n  raw_key_nonce, parent_key, expires, name, associated_data)\n      VALUES (\n        CASE WHEN raw_key IS NULL THEN\n            NEXTVAL('pgsodium.key_key_id_seq'::REGCLASS)\n        ELSE NULL END,\n        CASE WHEN raw_key IS NULL THEN\n            key_context\n        ELSE NULL END,\n        key_type,\n        raw_key,\n        CASE WHEN raw_key IS NOT NULL THEN\n            COALESCE(raw_key_nonce, pgsodium.crypto_aead_det_noncegen())\n        ELSE NULL END,\n        CASE WHEN parent_key IS NULL and raw_key IS NOT NULL THEN\n            (pgsodium.create_key('aead-det')).id\n        ELSE parent_key END,\n        expires,\n        name,\n        associated_data)\n    RETURNING * INTO new_key;\n  SELECT * INTO valid_key FROM pgsodium.valid_key WHERE id = new_key.id;\n  RETURN valid_key;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.randombytes_uniform(upper_bound integer)\n RETURNS integer\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_uniform$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.randombytes_buf(size integer)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_buf$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.quote_assoc(text, boolean DEFAULT false)\n RETURNS text\n LANGUAGE sql\nAS $function$\n    WITH a AS (SELECT array_agg(CASE WHEN $2 THEN\n                                    'new.' || quote_ident(trim(v))\n                                ELSE quote_ident(trim(v)) END) as r\n               FROM regexp_split_to_table($1, '\\s*,\\s*') as v)\n    SELECT array_to_string(a.r, '::text || ') || '::text' FROM a;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.randombytes_buf_deterministic(size integer, seed bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_randombytes_buf_deterministic$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size integer, subkey_id bigint, context bytea, primary_key uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE STRICT SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = primary_key AND key_type = 'kdf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_kdf_derive_from_key(subkey_size, subkey_id, context, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.derive_key(key.key_id, subkey_size, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n\n\nCREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n\n\nCREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n\n\nCREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.get_key_by_id(uuid)\n RETURNS pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key WHERE id = $1;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.get_key_by_name(text)\n RETURNS pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key WHERE name = $1;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.get_named_keys(filter text DEFAULT '%'::text)\n RETURNS SETOF pgsodium.valid_key\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    SELECT * from pgsodium.valid_key vk WHERE vk.name ILIKE filter;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.enable_security_label_trigger()\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update ENABLE;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.disable_security_label_trigger()\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update DISABLE;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.update_mask(target oid, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  PERFORM pgsodium.disable_security_label_trigger();\n  PERFORM pgsodium.create_mask_view(objoid, objsubid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    WHERE sl.objoid = target\n      AND sl.label ILIKE 'ENCRYPT%'\n      AND sl.provider = 'pgsodium';\n  PERFORM pgsodium.enable_security_label_trigger();\n  RETURN;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg1(state bytea, message bytea)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n SELECT pgsodium.crypto_sign_update(COALESCE(state, pgsodium.crypto_sign_init()), message);\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_update_agg2(cur_state bytea, initial_state bytea, message bytea)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n SELECT pgsodium.crypto_sign_update(\n       COALESCE(cur_state, initial_state),\n\t   message)\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.encrypted_columns(relid oid)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n    m RECORD;\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    IF m.key_id IS NULL AND m.key_id_column is NULL THEN\n      CONTINUE;\n    ELSE\n      expression := expression || comma;\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n                  pgsodium.crypto_aead_det_encrypt(\n                    pg_catalog.convert_to(%s, 'utf8'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'base64') END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE\n                        pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n                %s::uuid,\n                %s\n              ) END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      END IF;\n    END IF;\n    comma := E';\\n        ';\n  END LOOP;\n  RETURN expression;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.decrypted_columns(relid oid)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n  m RECORD;\n  expression TEXT;\n  comma TEXT;\n  padding text = '        ';\nBEGIN\n  expression := E'\\n';\n  comma := padding;\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    expression := expression || comma;\n    IF m.key_id IS NULL AND m.key_id_column IS NULL THEN\n      expression := expression || padding || quote_ident(m.attname);\n    ELSE\n      expression := expression || padding || quote_ident(m.attname) || E',\\n';\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.convert_from(\n                  pgsodium.crypto_aead_det_decrypt(\n                    pg_catalog.decode(%s, 'base64'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'utf8') END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                quote_ident('decrypted_' || m.attname)\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pgsodium.crypto_aead_det_decrypt(\n                    %s::bytea,\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ) END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                'decrypted_' || quote_ident(m.attname)\n          );\n      END IF;\n    END IF;\n    comma := E',       \\n';\n  END LOOP;\n  RETURN expression;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_encrypt_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_encrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_ietf_decrypt_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_ietf_decrypt(message bytea, additional bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth(message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_verify_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_verify(mac bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_verify(mac, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_verify(mac, message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_box_keypair\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seed_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box(message bytea, nonce bytea, public bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_open(ciphertext bytea, nonce bytea, public bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_open$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal(message bytea, public_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_box_seal_open(ciphertext bytea, public_key bytea, secret_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_box_seal_open$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_generichash$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_generichash(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'generichash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_generichash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_generichash(message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_shorthash$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_shorthash(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'shorthash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_shorthash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_shorthash(message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.sodium_bin2base64(bin bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_sodium_bin2base64$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.sodium_base642bin(base64 text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_sodium_base642bin$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512(message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, secret bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha512_verify_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha512_verify(signature bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, secret bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256(message bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256(message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, secret bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_auth_hmacsha256_verify_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_auth_hmacsha256_verify(signature bytea, message bytea, key_uuid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_kdf_derive_from_key(subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_kdf_derive_from_key$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash(password bytea, salt bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_pwhash_str_verify(hashed_password bytea, password bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_pwhash_str_verify$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox(message bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox(message, nonce, key.key_id, key.key_context);\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(ciphertext bytea, nonce bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_secretbox_open_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_secretbox_open(message bytea, nonce bytea, key_uuid uuid)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox_open(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox_open(message, nonce, key.key_id, key.key_context);\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha256(message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha256$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_hash_sha512(message bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_hash_sha512$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_detached(message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_detached$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_create(state bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_create$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_final_verify(state bytea, signature bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_final_verify$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_open(signed_message bytea, key bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_open$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_seed_new_keypair(seed bytea)\n RETURNS pgsodium.crypto_sign_keypair\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_seed_keypair$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_sign_verify_detached(sig bytea, message bytea, key bytea)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_sign_verify_detached$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_after(state bytea, sender_sk bytea, ciphertext bytea)\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_after$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_sign_before(sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea)\n RETURNS pgsodium.crypto_signcrypt_state_key\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_sign_before$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_after(state bytea, signature bytea, sender_pk bytea, ciphertext bytea)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_after$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_before(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea)\n RETURNS pgsodium.crypto_signcrypt_state_key\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_before$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_signcrypt_verify_public(signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_signcrypt_verify_public$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20(bigint, bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor(bytea, bytea, bigint, context bytea DEFAULT '\\x70676f736469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_stream_xchacha20_xor_ic(bytea, bytea, bigint, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/pgsodium', $function$pgsodium_crypto_stream_xchacha20_xor_ic_by_id$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.encrypted_column(relid oid, m record)\n RETURNS text\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  expression := expression || comma;\n  IF m.format_type = 'text' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(%s, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t\t%s::uuid,\n\t\t\t\t%s\n\t\t\t  ),\n\t\t\t\t'base64') END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  ELSIF m.format_type = 'bytea' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t%s::uuid,\n\t\t\t%s\n\t\t  ) END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  END IF;\n  comma := E';\\n        ';\n  RETURN expression;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.update_masks(debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nBEGIN\n  PERFORM pgsodium.update_mask(objoid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    JOIN pg_catalog.pg_class cl ON (cl.oid = sl.objoid)\n    WHERE label ilike 'ENCRYPT%'\n       AND cl.relowner = session_user::regrole::oid\n       AND provider = 'pgsodium'\n\t   AND objoid::regclass != 'pgsodium.key'::regclass\n\t;\n  RETURN;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.key_encrypt_secret_raw_key()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n\t\tBEGIN\n\t\t        new.raw_key = CASE WHEN new.raw_key IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.parent_key IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(new.raw_key::bytea, pg_catalog.convert_to((new.id::text || new.associated_data::text)::text, 'utf8'),\n\t\t\tnew.parent_key::uuid,\n\t\t\tnew.raw_key_nonce\n\t\t  ) END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.create_mask_view(relid oid, subid integer, debug boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog'\nAS $function$\nDECLARE\n  m record;\n  body text;\n  source_name text;\n  view_owner regrole = session_user;\n  rule pgsodium.masking_rule;\n  privs aclitem[];\n  priv record;\nBEGIN\n  SELECT DISTINCT * INTO STRICT rule FROM pgsodium.masking_rule WHERE attrelid = relid AND attnum = subid;\n\n  source_name := relid::regclass::text;\n\n  BEGIN\n    SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = rule.view_name::regclass::oid;\n  EXCEPTION\n\tWHEN undefined_table THEN\n      SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = relid;\n  END;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS %1$s;\n    CREATE VIEW %1$s %5$s AS SELECT %2$s\n    FROM %3$s;\n    ALTER VIEW %1$s OWNER TO %4$s;\n    $c$,\n    rule.view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name,\n    view_owner,\n    CASE WHEN rule.security_invoker THEN 'WITH (security_invoker=true)' ELSE '' END\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  FOR priv IN SELECT * FROM pg_catalog.aclexplode(privs) LOOP\n\tbody = format(\n\t  $c$\n\t  GRANT %s ON %s TO %s;\n\t  $c$,\n\t  priv.privilege_type,\n\t  rule.view_name,\n\t  priv.grantee::regrole::text\n\t);\n\tIF debug THEN\n\t  RAISE NOTICE '%', body;\n\tEND IF;\n\tEXECUTE body;\n  END LOOP;\n\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n\tIF m.key_id IS NULL AND m.key_id_column is NULL THEN\n\t  CONTINUE;\n\tELSE\n\t  body = format(\n\t\t$c$\n\t\tDROP FUNCTION IF EXISTS %1$s.\"%2$s_encrypt_secret_%3$s\"() CASCADE;\n\n\t\tCREATE OR REPLACE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\"()\n\t\t  RETURNS TRIGGER\n\t\t  LANGUAGE plpgsql\n\t\t  AS $t$\n\t\tBEGIN\n\t\t%4$s;\n\t\tRETURN new;\n\t\tEND;\n\t\t$t$;\n\n\t\tALTER FUNCTION  %1$s.\"%2$s_encrypt_secret_%3$s\"() OWNER TO %5$s;\n\n\t\tDROP TRIGGER IF EXISTS \"%2$s_encrypt_secret_trigger_%3$s\" ON %6$s;\n\n\t\tCREATE TRIGGER \"%2$s_encrypt_secret_trigger_%3$s\"\n\t\t  BEFORE INSERT OR UPDATE OF \"%3$s\" ON %6$s\n\t\t  FOR EACH ROW\n\t\t  EXECUTE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\" ();\n\t\t  $c$,\n\t\trule.relnamespace,\n\t\trule.relname,\n\t\tm.attname,\n\t\tpgsodium.encrypted_column(relid, m),\n\t\tview_owner,\n\t\tsource_name\n\t  );\n\t  if debug THEN\n\t\tRAISE NOTICE '%', body;\n\t  END IF;\n\t  EXECUTE body;\n\tEND IF;\n  END LOOP;\n\n  raise notice 'about to masking role % %', source_name, rule.view_name;\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, rule.view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.trg_mask_update()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SET search_path TO ''\nAS $function$\nDECLARE\n  r record;\nBEGIN\n  IF (SELECT bool_or(in_extension) FROM pg_event_trigger_ddl_commands()) THEN\n    RAISE NOTICE 'skipping pgsodium mask regeneration in extension';\n\tRETURN;\n  END IF;\n\n  FOR r IN\n    SELECT e.*\n    FROM pg_event_trigger_ddl_commands() e\n    WHERE EXISTS (\n      SELECT FROM pg_catalog.pg_class c\n      JOIN pg_catalog.pg_seclabel s ON s.classoid = c.tableoid\n                                   AND s.objoid = c.oid\n      WHERE c.tableoid = e.classid\n        AND e.objid = c.oid\n        AND s.provider = 'pgsodium'\n    )\n  LOOP\n    IF r.object_type in ('table', 'table column')\n    THEN\n      PERFORM pgsodium.update_mask(r.objid);\n    END IF;\n  END LOOP;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.mask_role(masked_role regrole, source_name text, view_name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\n    BEGIN\n      EXECUTE format(\n        'GRANT SELECT ON pgsodium.key TO %s',\n        masked_role);\n\n      EXECUTE format(\n        'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',\n        masked_role);\n\n      EXECUTE format(\n        'GRANT ALL ON %I TO %s',\n        view_name,\n        masked_role);\n      RETURN;\n    END\n    $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_keygen()\n RETURNS bytea\n LANGUAGE c\nAS '$libdir/pgsodium', $function$pgsodium_crypto_aead_det_keygen$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)\n RETURNS void\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n\n\nCREATE OR REPLACE FUNCTION public.corrigir_permissoes_auth()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_count INT := 0;\r\nBEGIN\r\n    -- Garantir que o schema auth existe\r\n    IF NOT EXISTS (SELECT 1 FROM pg_namespace WHERE nspname = 'auth') THEN\r\n        RAISE EXCEPTION 'Schema auth não existe';\r\n    END IF;\r\n    \r\n    -- Garantir que o usuário service_role tem acesso às tabelas auth\r\n    GRANT USAGE ON SCHEMA auth TO service_role;\r\n    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA auth TO service_role;\r\n    GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA auth TO service_role;\r\n    \r\n    -- Garantir que a função de login funciona\r\n    GRANT EXECUTE ON FUNCTION auth.email_login(text, text, text, text) TO service_role;\r\n    \r\n    v_count := v_count + 1;\r\n    \r\n    RETURN 'Permissões corrigidas: ' || v_count || ' operações';\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.configurar_tabela_franquias()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    column_exists BOOLEAN;\r\n    responsavel_exists BOOLEAN;\r\nBEGIN\r\n    -- Verificar se a coluna 'user_id' existe na tabela franquias\r\n    SELECT EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_name = 'franquias'\r\n        AND column_name = 'user_id'\r\n    ) INTO column_exists;\r\n\r\n    -- Se a coluna 'user_id' não existir, criá-la\r\n    IF NOT column_exists THEN\r\n        EXECUTE '\r\n            ALTER TABLE public.franquias\r\n            ADD COLUMN user_id UUID NULL,\r\n            ADD CONSTRAINT fk_user\r\n                FOREIGN KEY (user_id)\r\n                REFERENCES auth.users(id)\r\n                ON DELETE SET NULL;\r\n        ';\r\n        RAISE NOTICE 'Coluna user_id criada na tabela franquias';\r\n    END IF;\r\n\r\n    -- Verificar se a coluna 'responsavel' existe\r\n    SELECT EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_name = 'franquias'\r\n        AND column_name = 'responsavel'\r\n    ) INTO responsavel_exists;\r\n\r\n    -- Se a coluna 'responsavel' existir, removê-la\r\n    IF responsavel_exists THEN\r\n        EXECUTE '\r\n            ALTER TABLE public.franquias\r\n            DROP COLUMN IF EXISTS responsavel;\r\n        ';\r\n        RAISE NOTICE 'Coluna responsavel removida da tabela franquias';\r\n    END IF;\r\n\r\n    -- Verificar se a coluna 'ativa' existe na tabela franquias\r\n    SELECT EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_name = 'franquias'\r\n        AND column_name = 'ativa'\r\n    ) INTO column_exists;\r\n\r\n    -- Se a coluna 'ativa' não existir, criá-la\r\n    IF NOT column_exists THEN\r\n        EXECUTE '\r\n            ALTER TABLE public.franquias\r\n            ADD COLUMN ativa BOOLEAN DEFAULT TRUE;\r\n        ';\r\n        RAISE NOTICE 'Coluna ativa criada na tabela franquias';\r\n    END IF;\r\n\r\n    RETURN TRUE;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Erro ao configurar tabela de franquias: %', SQLERRM;\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.confirmar_emails_usuarios()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_count INT;\r\nBEGIN\r\n    UPDATE auth.users\r\n    SET email_confirmed_at = NOW()\r\n    WHERE email_confirmed_at IS NULL;\r\n    \r\n    GET DIAGNOSTICS v_count = ROW_COUNT;\r\n    \r\n    RETURN 'Confirmados ' || v_count || ' usuários';\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.create_update_timestamp_function(function_definition text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    EXECUTE function_definition;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.atribuir_permissao_admin(email_usuario text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_result json;\r\nBEGIN\r\n  -- Obter o ID do usuário pelo email\r\n  SELECT id INTO v_user_id FROM auth.users WHERE email = email_usuario;\r\n  \r\n  IF v_user_id IS NULL THEN\r\n    RETURN json_build_object('success', false, 'message', 'Usuário não encontrado');\r\n  END IF;\r\n  \r\n  -- Atualizar os metadados do usuário\r\n  UPDATE auth.users\r\n  SET raw_app_meta_data = raw_app_meta_data || '{\"role\": \"admin\"}'::jsonb\r\n  WHERE id = v_user_id;\r\n  \r\n  RETURN json_build_object('success', true, 'message', 'Permissões de administrador concedidas com sucesso');\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object('success', false, 'message', SQLERRM);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RAISE WARNING 'PgBouncer auth request: %', p_usename;\n\n    RETURN QUERY\n    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow\n    WHERE usename = p_usename;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.garantir_permissoes_matriz()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\nBEGIN\r\n    -- Verificar se existem permissões\r\n    IF NOT EXISTS (SELECT 1 FROM public.permissoes LIMIT 1) THEN\r\n        -- Inserir permissões básicas\r\n        INSERT INTO public.permissoes (nome, descricao, codigo)\r\n        VALUES \r\n            ('Dashboard', 'Acesso ao dashboard', 'dashboard'),\r\n            ('Gerenciar Clientes', 'Permissão para gerenciar clientes', 'gerenciar_clientes'),\r\n            ('Visualizar Clientes', 'Permissão para visualizar clientes', 'visualizar_clientes'),\r\n            ('Visualizar Licitações', 'Permissão para visualizar licitações', 'visualizar_licitacoes'),\r\n            ('Gerenciar Documentos', 'Permissão para gerenciar documentos', 'gerenciar_documentos'),\r\n            ('Visualizar Documentos', 'Permissão para visualizar documentos', 'visualizar_documentos'),\r\n            ('Visualizar Prazos', 'Permissão para visualizar prazos', 'visualizar_prazos'),\r\n            ('Visualizar Relatórios', 'Permissão para visualizar relatórios', 'visualizar_relatorios'),\r\n            ('Gerenciar Franquias', 'Permissão para gerenciar franquias', 'gerenciar_franquias'),\r\n            ('Gerenciar Permissões', 'Permissão para gerenciar permissões', 'gerenciar_permissoes')\r\n        ON CONFLICT (codigo) DO NOTHING;\r\n    END IF;\r\n    \r\n    -- Configurar permissões padrão para MATRIZ\r\n    INSERT INTO public.permissoes_tipo_usuario (tipo_usuario, permissao_id, ativo)\r\n    SELECT 'MATRIZ'::tipo_usuario, id, TRUE FROM public.permissoes \r\n    WHERE codigo IN (\r\n        'dashboard', \r\n        'gerenciar_clientes', \r\n        'visualizar_clientes', \r\n        'visualizar_licitacoes', \r\n        'gerenciar_documentos', \r\n        'visualizar_documentos', \r\n        'visualizar_prazos', \r\n        'visualizar_relatorios',\r\n        'gerenciar_franquias',\r\n        'gerenciar_permissoes'\r\n    )\r\n    ON CONFLICT (tipo_usuario, permissao_id) DO NOTHING;\r\n    \r\n    -- Configurar permissões padrão para FRANQUIA\r\n    INSERT INTO public.permissoes_tipo_usuario (tipo_usuario, permissao_id, ativo)\r\n    SELECT 'FRANQUIA'::tipo_usuario, id, TRUE FROM public.permissoes \r\n    WHERE codigo IN (\r\n        'dashboard', \r\n        'gerenciar_clientes', \r\n        'visualizar_clientes', \r\n        'visualizar_licitacoes', \r\n        'gerenciar_documentos', \r\n        'visualizar_documentos', \r\n        'visualizar_prazos', \r\n        'visualizar_relatorios'\r\n    )\r\n    ON CONFLICT (tipo_usuario, permissao_id) DO NOTHING;\r\n    \r\n    -- Configurar permissões padrão para CLIENTE\r\n    INSERT INTO public.permissoes_tipo_usuario (tipo_usuario, permissao_id, ativo)\r\n    SELECT 'CLIENTE'::tipo_usuario, id, TRUE FROM public.permissoes \r\n    WHERE codigo IN (\r\n        'dashboard', \r\n        'visualizar_licitacoes', \r\n        'visualizar_documentos'\r\n    )\r\n    ON CONFLICT (tipo_usuario, permissao_id) DO NOTHING;\r\n    \r\n    -- Obter o usuário atual\r\n    SELECT auth.uid() INTO v_user_id;\r\n    \r\n    -- Se encontrou o usuário, verificar se já tem perfil\r\n    IF v_user_id IS NOT NULL THEN\r\n        -- Se não tiver perfil, criar um perfil MATRIZ\r\n        IF NOT EXISTS (SELECT 1 FROM public.perfis_usuario WHERE user_id = v_user_id) THEN\r\n            INSERT INTO public.perfis_usuario (user_id, tipo, nome)\r\n            VALUES (v_user_id, 'MATRIZ'::tipo_usuario, 'Administrador')\r\n            ON CONFLICT (user_id) DO UPDATE\r\n            SET tipo = 'MATRIZ'::tipo_usuario, nome = 'Administrador', updated_at = CURRENT_TIMESTAMP;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN TRUE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_clientes_por_cnae(p_codigo_cnae text)\n RETURNS SETOF clientes\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT *\r\n    FROM public.clientes\r\n    WHERE EXISTS (\r\n        SELECT 1\r\n        FROM jsonb_array_elements(cnaes) AS cnae\r\n        WHERE cnae->>'codigo' LIKE '%' || p_codigo_cnae || '%'\r\n    );\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_clientes_por_ramo(p_ramo_atividade text)\n RETURNS TABLE(id uuid, razao_social character varying, cnpj character varying, email character varying, cidade character varying, estado character varying)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        c.id,\r\n        c.razao_social,\r\n        c.cnpj,\r\n        c.email,\r\n        c.cidade,\r\n        c.estado\r\n    FROM clientes c\r\n    WHERE p_ramo_atividade = ANY(c.ramos_atividade)\r\n    ORDER BY c.razao_social;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_prazos_por_periodo(p_data_inicio timestamp with time zone, p_data_fim timestamp with time zone)\n RETURNS SETOF prazos\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT p.* \r\n    FROM public.prazos p\r\n    WHERE p.data_prazo BETWEEN p_data_inicio AND p_data_fim\r\n    ORDER BY p.data_prazo ASC;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.check_user_exists(p_email text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (SELECT 1 FROM auth.users WHERE email = p_email);\r\nEXCEPTION WHEN OTHERS THEN\r\n  RAISE WARNING 'Erro ao verificar usuário: %', SQLERRM;\r\n  RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_licitacoes_por_cliente(p_cliente_id uuid)\n RETURNS SETOF licitacoes\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT * FROM public.licitacoes\r\n    WHERE cliente_id = p_cliente_id\r\n    ORDER BY data_abertura DESC;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_licitacoes_por_periodo(p_data_inicio timestamp with time zone, p_data_fim timestamp with time zone)\n RETURNS SETOF licitacoes\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT * FROM public.licitacoes\r\n    WHERE data_abertura BETWEEN p_data_inicio AND p_data_fim\r\n    ORDER BY data_abertura DESC;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_licitacoes_por_ramo(p_ramo_atividade text)\n RETURNS SETOF licitacoes\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT * FROM public.licitacoes \r\n    WHERE p_ramo_atividade = ANY(ramos_atividade) \r\n    ORDER BY data_abertura DESC;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_prazos_por_licitacao(p_licitacao_id uuid)\n RETURNS SETOF prazos\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT p.* \r\n    FROM public.prazos p\r\n    INNER JOIN public.licitacoes l ON p.licitacao_id = l.id\r\n    WHERE p.licitacao_id = p_licitacao_id\r\n    ORDER BY p.data_prazo ASC;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_extensoes()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Criar a extensão pgcrypto se não existir\r\n    CREATE EXTENSION IF NOT EXISTS pgcrypto;\r\n    \r\n    -- Criar a extensão uuid-ossp se não existir\r\n    CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Erro ao criar extensões: %', SQLERRM;\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.desvincular_cliente_franquia(p_cliente_id uuid, p_matriz_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Verificar se o cliente existe\r\n  IF NOT EXISTS (SELECT 1 FROM clientes WHERE id = p_cliente_id) THEN\r\n    RAISE EXCEPTION 'Cliente não encontrado';\r\n  END IF;\r\n  \r\n  -- Verificar se o usuário matriz existe\r\n  IF NOT EXISTS (SELECT 1 FROM perfis_usuario WHERE user_id = p_matriz_id AND tipo = 'MATRIZ') THEN\r\n    RAISE EXCEPTION 'Usuário matriz não encontrado';\r\n  END IF;\r\n  \r\n  -- Verificar se o cliente pertence à matriz\r\n  IF NOT EXISTS (SELECT 1 FROM clientes WHERE id = p_cliente_id AND matriz_id = p_matriz_id) THEN\r\n    RAISE EXCEPTION 'Cliente não pertence a esta matriz';\r\n  END IF;\r\n  \r\n  -- Desvincular o cliente da franquia\r\n  UPDATE clientes\r\n  SET franquia_id = NULL,\r\n      data_vinculo = NOW(),\r\n      updated_at = NOW()\r\n  WHERE id = p_cliente_id;\r\n  \r\n  RETURN TRUE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_perfil_matriz()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_email TEXT;\r\nBEGIN\r\n    -- Obter o usuário atual\r\n    SELECT auth.uid() INTO v_user_id;\r\n    \r\n    -- Se não encontrou usuário, retorna falso\r\n    IF v_user_id IS NULL THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Obter o email do usuário\r\n    SELECT email INTO v_email FROM auth.users WHERE id = v_user_id;\r\n    \r\n    -- Criar perfil MATRIZ para o usuário atual\r\n    INSERT INTO public.perfis_usuario (user_id, tipo, nome)\r\n    VALUES (\r\n        v_user_id, \r\n        'MATRIZ'::tipo_usuario, \r\n        COALESCE(\r\n            SPLIT_PART(v_email, '@', 1), \r\n            'Administrador'\r\n        )\r\n    )\r\n    ON CONFLICT (user_id) DO UPDATE\r\n    SET \r\n        tipo = 'MATRIZ'::tipo_usuario, \r\n        nome = COALESCE(\r\n            SPLIT_PART(v_email, '@', 1), \r\n            'Administrador'\r\n        ), \r\n        updated_at = CURRENT_TIMESTAMP;\r\n    \r\n    RETURN TRUE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_franquia_com_usuario(p_nome character varying, p_cnpj character varying, p_email character varying, p_telefone character varying, p_responsavel character varying, p_senha character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_franquia_id UUID;\r\n    v_resultado jsonb;\r\nBEGIN\r\n    -- Verificar se já existe uma franquia com o mesmo CNPJ\r\n    IF EXISTS (SELECT 1 FROM public.franquias WHERE cnpj = p_cnpj) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe uma franquia com este CNPJ'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se já existe um usuário com o mesmo email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe um usuário com este email'\r\n        );\r\n    END IF;\r\n\r\n    -- Criar o usuário\r\n    INSERT INTO auth.users (\r\n        email,\r\n        encrypted_password,\r\n        email_confirmed_at,\r\n        raw_app_meta_data,\r\n        raw_user_meta_data\r\n    ) VALUES (\r\n        p_email,\r\n        crypt(p_senha, gen_salt('bf')),\r\n        now(),\r\n        '{\"provider\":\"email\",\"providers\":[\"email\"],\"role\":\"franquia\"}'::jsonb,\r\n        jsonb_build_object('nome', p_responsavel)\r\n    )\r\n    RETURNING id INTO v_user_id;\r\n\r\n    -- Criar a franquia\r\n    INSERT INTO public.franquias (\r\n        nome,\r\n        cnpj,\r\n        email,\r\n        telefone,\r\n        responsavel,\r\n        user_id\r\n    ) VALUES (\r\n        p_nome,\r\n        p_cnpj,\r\n        p_email,\r\n        p_telefone,\r\n        p_responsavel,\r\n        v_user_id\r\n    )\r\n    RETURNING id INTO v_franquia_id;\r\n\r\n    RETURN jsonb_build_object(\r\n        'sucesso', true,\r\n        'mensagem', 'Franquia criada com sucesso',\r\n        'user_id', v_user_id,\r\n        'franquia_id', v_franquia_id\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'sucesso', false,\r\n        'mensagem', 'Erro ao criar franquia: ' || SQLERRM\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_franquia_com_usuario(p_nome character varying, p_cnpj character varying, p_email character varying, p_telefone character varying, p_senha character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_franquia_id UUID;\r\n    v_resultado jsonb;\r\nBEGIN\r\n    -- Verificar se já existe uma franquia com o mesmo CNPJ\r\n    IF EXISTS (SELECT 1 FROM public.franquias WHERE cnpj = p_cnpj) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe uma franquia com este CNPJ'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se já existe um usuário com o mesmo email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe um usuário com este email'\r\n        );\r\n    END IF;\r\n\r\n    -- Criar o usuário\r\n    INSERT INTO auth.users (\r\n        email,\r\n        encrypted_password,\r\n        email_confirmed_at,\r\n        raw_app_meta_data,\r\n        raw_user_meta_data\r\n    ) VALUES (\r\n        p_email,\r\n        crypt(p_senha, gen_salt('bf')),\r\n        now(),\r\n        '{\"provider\":\"email\",\"providers\":[\"email\"],\"role\":\"franquia\"}'::jsonb,\r\n        jsonb_build_object('nome', p_nome)\r\n    )\r\n    RETURNING id INTO v_user_id;\r\n\r\n    -- Criar a franquia\r\n    INSERT INTO public.franquias (\r\n        nome,\r\n        cnpj,\r\n        email,\r\n        telefone,\r\n        user_id\r\n    ) VALUES (\r\n        p_nome,\r\n        p_cnpj,\r\n        p_email,\r\n        p_telefone,\r\n        v_user_id\r\n    )\r\n    RETURNING id INTO v_franquia_id;\r\n\r\n    RETURN jsonb_build_object(\r\n        'sucesso', true,\r\n        'mensagem', 'Franquia criada com sucesso',\r\n        'user_id', v_user_id,\r\n        'franquia_id', v_franquia_id\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'sucesso', false,\r\n        'mensagem', 'Erro ao criar franquia: ' || SQLERRM\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.gerar_relatorio_desempenho_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN relatorio_desempenho_v3(p_data_inicio, p_data_fim);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.garantir_user_id_nullable()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Verifica se a tabela franquias existe\r\n    IF EXISTS (\r\n        SELECT FROM pg_tables\r\n        WHERE schemaname = 'public'\r\n        AND tablename = 'franquias'\r\n    ) THEN\r\n        -- Verifica se a coluna user_id existe e é NOT NULL\r\n        IF EXISTS (\r\n            SELECT FROM information_schema.columns\r\n            WHERE table_schema = 'public'\r\n            AND table_name = 'franquias'\r\n            AND column_name = 'user_id'\r\n            AND is_nullable = 'NO'\r\n        ) THEN\r\n            -- Modifica a coluna para permitir NULL\r\n            EXECUTE 'ALTER TABLE public.franquias ALTER COLUMN user_id DROP NOT NULL;';\r\n        END IF;\r\n    END IF;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.gerar_relatorio_clientes_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN relatorio_clientes_v3(p_data_inicio, p_data_fim);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.excluir_documento_licitacao(p_documento_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_documento RECORD;\r\n    v_is_edital boolean;\r\n    v_outros_editais integer;\r\n    v_licitacao_id uuid;\r\nBEGIN\r\n    -- Obter informações do documento\r\n    SELECT \r\n        dl.id, \r\n        dl.licitacao_id, \r\n        dl.arquivo_url,\r\n        td.nome AS tipo_documento_nome\r\n    INTO v_documento\r\n    FROM \r\n        documentos_licitacao dl\r\n        JOIN tipos_documentos td ON dl.tipo_documento_id = td.id\r\n    WHERE \r\n        dl.id = p_documento_id;\r\n    \r\n    -- Verificar se o documento existe\r\n    IF v_documento.id IS NULL THEN\r\n        RAISE EXCEPTION 'Documento não encontrado';\r\n    END IF;\r\n    \r\n    -- Armazenar o ID da licitação para uso posterior\r\n    v_licitacao_id := v_documento.licitacao_id;\r\n    \r\n    -- Verificar se é um edital\r\n    v_is_edital := v_documento.tipo_documento_nome ILIKE '%edital%';\r\n    \r\n    -- Se for um edital, verificar se é o último\r\n    IF v_is_edital THEN\r\n        -- Contar outros editais para esta licitação\r\n        SELECT COUNT(*)\r\n        INTO v_outros_editais\r\n        FROM \r\n            documentos_licitacao dl\r\n            JOIN tipos_documentos td ON dl.tipo_documento_id = td.id\r\n        WHERE \r\n            dl.licitacao_id = v_licitacao_id\r\n            AND dl.id != p_documento_id\r\n            AND td.nome ILIKE '%edital%';\r\n        \r\n        -- Se for o último edital, excluir os requisitos\r\n        IF v_outros_editais = 0 THEN\r\n            RAISE NOTICE 'Este é o último edital da licitação %. Excluindo requisitos associados.', v_licitacao_id;\r\n            \r\n            DELETE FROM requisitos_documentacao\r\n            WHERE licitacao_id = v_licitacao_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Excluir o arquivo do storage (isso deve ser feito no código JavaScript)\r\n    \r\n    -- Excluir o registro do documento\r\n    DELETE FROM documentos_licitacao\r\n    WHERE id = p_documento_id;\r\n    \r\n    RETURN true;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.ensure_franquias_ativa_column()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    column_exists BOOLEAN;\r\nBEGIN\r\n    -- Verificar se a tabela franquias existe\r\n    IF NOT EXISTS (\r\n        SELECT FROM information_schema.tables \r\n        WHERE table_schema = 'public' \r\n        AND table_name = 'franquias'\r\n    ) THEN\r\n        RAISE EXCEPTION 'A tabela franquias não existe no banco de dados';\r\n        RETURN FALSE;\r\n    END IF;\r\n\r\n    -- Verificar se a coluna 'ativa' existe na tabela franquias\r\n    SELECT EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_schema = 'public'\r\n        AND table_name = 'franquias'\r\n        AND column_name = 'ativa'\r\n    ) INTO column_exists;\r\n\r\n    -- Se a coluna 'ativa' não existir, criá-la\r\n    IF NOT column_exists THEN\r\n        EXECUTE '\r\n            ALTER TABLE public.franquias\r\n            ADD COLUMN ativa BOOLEAN DEFAULT TRUE;\r\n        ';\r\n        RAISE NOTICE 'Coluna ativa criada na tabela franquias';\r\n        RETURN TRUE;\r\n    ELSE\r\n        RAISE NOTICE 'Coluna ativa já existe na tabela franquias';\r\n        RETURN TRUE;\r\n    END IF;\r\n\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Erro ao verificar/adicionar coluna ativa: %', SQLERRM;\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_usuario_para_franquia(p_franquia_id uuid, p_email character varying, p_senha character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_franquia_record RECORD;\r\n    v_user_id UUID;\r\n    v_result JSONB;\r\n    v_error TEXT;\r\n    v_deleted_email VARCHAR := 'deleted_' || p_email;\r\nBEGIN\r\n    -- Verifica se a franquia existe\r\n    SELECT * INTO v_franquia_record FROM public.franquias WHERE id = p_franquia_id;\r\n    IF NOT FOUND THEN\r\n        RETURN jsonb_build_object('success', false, 'error', 'Franquia não encontrada');\r\n    END IF;\r\n    \r\n    -- Verifica se já existe um usuário com este email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object('success', false, 'error', 'Email já está em uso');\r\n    END IF;\r\n    \r\n    -- Verifica se existe um usuário excluído com soft delete (email = 'deleted_[email]')\r\n    -- Se existir, podemos reutilizá-lo revertendo o soft delete\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = v_deleted_email) THEN\r\n        -- Encontrou um usuário que foi excluído com soft delete\r\n        SELECT id INTO v_user_id FROM auth.users WHERE email = v_deleted_email;\r\n        \r\n        -- Restaura o usuário\r\n        UPDATE auth.users\r\n        SET \r\n            email = p_email,\r\n            encrypted_password = crypt(p_senha, gen_salt('bf')),\r\n            email_confirmed_at = NOW(),\r\n            banned_until = NULL,\r\n            raw_app_meta_data = jsonb_set(\r\n                COALESCE(raw_app_meta_data, '{}'::jsonb) - 'deletedAt',\r\n                '{provider}',\r\n                '\"email\"'\r\n            ),\r\n            raw_user_meta_data = jsonb_set(\r\n                COALESCE(raw_user_meta_data, '{}'::jsonb) - 'deletedAt',\r\n                '{full_name}',\r\n                to_jsonb(v_franquia_record.nome)\r\n            ),\r\n            updated_at = NOW()\r\n        WHERE id = v_user_id;\r\n        \r\n        -- Associa o ID do usuário restaurado à franquia\r\n        UPDATE public.franquias SET user_id = v_user_id WHERE id = p_franquia_id;\r\n        \r\n        RETURN jsonb_build_object(\r\n            'success', true, \r\n            'user_id', v_user_id, \r\n            'reactivated', true\r\n        );\r\n    END IF;\r\n    \r\n    -- Não existe usuário com este email, criar um novo\r\n    INSERT INTO auth.users (\r\n        email,\r\n        raw_user_meta_data,\r\n        role\r\n    ) VALUES (\r\n        p_email,\r\n        jsonb_build_object('full_name', v_franquia_record.nome),\r\n        'franquia'\r\n    )\r\n    RETURNING id INTO v_user_id;\r\n    \r\n    -- Associa o ID do usuário à franquia\r\n    UPDATE public.franquias SET user_id = v_user_id WHERE id = p_franquia_id;\r\n    \r\n    -- Define a senha do usuário\r\n    BEGIN\r\n        UPDATE auth.users\r\n        SET encrypted_password = crypt(p_senha, gen_salt('bf'))\r\n        WHERE id = v_user_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        v_error := SQLERRM;\r\n        RETURN jsonb_build_object('success', false, 'error', v_error);\r\n    END;\r\n    \r\n    -- Confirma o email do usuário\r\n    UPDATE auth.users SET email_confirmed_at = NOW() WHERE id = v_user_id;\r\n    \r\n    RETURN jsonb_build_object('success', true, 'user_id', v_user_id, 'new_user', true);\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        v_error := SQLERRM;\r\n        RETURN jsonb_build_object('success', false, 'error', v_error);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_usuario_franquia_v2(p_franquia_id uuid, p_email character varying, p_senha character varying, p_nome character varying DEFAULT NULL::character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_franquia_nome VARCHAR;\r\n    v_email VARCHAR;\r\n    v_user_data JSONB;\r\n    v_role VARCHAR := 'authenticated';\r\n    v_timestamp BIGINT;\r\n    v_seed TEXT;\r\n    v_encrypted_password TEXT;\r\nBEGIN\r\n    -- Validar parâmetros de entrada\r\n    IF p_franquia_id IS NULL THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'ID da franquia não pode ser nulo',\r\n            'codigo', 'FRANQUIA_ID_NULO'\r\n        );\r\n    END IF;\r\n\r\n    IF p_email IS NULL OR p_email = '' THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Email não pode ser nulo ou vazio',\r\n            'codigo', 'EMAIL_INVALIDO'\r\n        );\r\n    END IF;\r\n\r\n    IF p_senha IS NULL OR length(p_senha) < 6 THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Senha deve ter pelo menos 6 caracteres',\r\n            'codigo', 'SENHA_INVALIDA'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se a franquia existe\r\n    IF NOT EXISTS (SELECT 1 FROM public.franquias WHERE id = p_franquia_id) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Franquia não encontrada. ID: ' || p_franquia_id::text,\r\n            'codigo', 'FRANQUIA_NAO_ENCONTRADA'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se já existe um usuário com o mesmo email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe um usuário com este email: ' || p_email,\r\n            'codigo', 'EMAIL_JA_EXISTE'\r\n        );\r\n    END IF;\r\n\r\n    -- Obter informações da franquia\r\n    SELECT nome, email \r\n    INTO v_franquia_nome, v_email\r\n    FROM public.franquias \r\n    WHERE id = p_franquia_id;\r\n\r\n    -- Se o nome do responsável não foi fornecido, usar o nome da franquia\r\n    IF p_nome IS NULL OR p_nome = '' THEN\r\n        p_nome := v_franquia_nome;\r\n    END IF;\r\n\r\n    -- Utilizar o email da franquia se não for fornecido\r\n    IF p_email IS NULL OR p_email = '' THEN\r\n        p_email := v_email;\r\n    END IF;\r\n\r\n    -- Gerar um UUID para o usuário usando timestamp e texto único\r\n    SELECT EXTRACT(EPOCH FROM NOW()) * 1000 INTO v_timestamp;\r\n    v_seed := p_email || '_' || v_timestamp::TEXT;\r\n    v_user_id := (SELECT md5(v_seed)::uuid);  -- Converter o MD5 do seed para UUID\r\n    \r\n    -- Gerar uma senha encriptada simples\r\n    v_encrypted_password := 'TEMP_' || MD5(p_senha || '_' || p_email);\r\n\r\n    -- Usar a função de sign-up do Supabase\r\n    BEGIN\r\n        v_user_data := jsonb_build_object(\r\n            'email', p_email,\r\n            'password', p_senha,\r\n            'email_confirm', TRUE,\r\n            'data', jsonb_build_object('nome', p_nome)\r\n        );\r\n        \r\n        -- Utilizar API do GoTrue/Supabase Auth para criar o usuário\r\n        PERFORM\r\n            pg_notify(\r\n                'supabase_functions',\r\n                jsonb_build_object(\r\n                    'type', 'signup',\r\n                    'event', 'user_create',\r\n                    'payload', v_user_data\r\n                )::text\r\n            );\r\n            \r\n        -- Como não temos acesso direto ao retorno da notificação, inserimos o usuário manualmente\r\n        -- com uma senha simples temporária, que deve ser alterada pelo usuário\r\n        INSERT INTO auth.users\r\n            (id, instance_id, email, encrypted_password, email_confirmed_at, \r\n             aud, role, raw_app_meta_data, raw_user_meta_data, created_at, updated_at)\r\n        VALUES\r\n            (v_user_id, '00000000-0000-0000-0000-000000000000', p_email, \r\n             v_encrypted_password, \r\n             now(), \r\n             'authenticated', v_role, \r\n             jsonb_build_object('provider', 'email', 'providers', ARRAY['email'], 'role', 'franquia'),\r\n             jsonb_build_object('nome', p_nome),\r\n             now(), now())\r\n        RETURNING id INTO v_user_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Erro ao criar usuário: ' || SQLERRM,\r\n            'codigo', 'ERRO_CRIAR_USUARIO',\r\n            'detalhe', SQLERRM,\r\n            'sqlstate', SQLSTATE\r\n        );\r\n    END;\r\n\r\n    -- Atualizar user_id na franquia\r\n    BEGIN\r\n        UPDATE public.franquias\r\n        SET user_id = v_user_id\r\n        WHERE id = p_franquia_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        -- Se falhar ao atualizar franquia, ainda retornar sucesso na criação do usuário\r\n        RETURN jsonb_build_object(\r\n            'sucesso', true,\r\n            'mensagem', 'Usuário criado, mas não foi possível associá-lo à franquia. Erro: ' || SQLERRM,\r\n            'user_id', v_user_id,\r\n            'franquia_id', p_franquia_id,\r\n            'codigo', 'ERRO_ASSOCIAR_USUARIO'\r\n        );\r\n    END;\r\n\r\n    RETURN jsonb_build_object(\r\n        'sucesso', true,\r\n        'mensagem', 'Usuário da franquia criado com sucesso',\r\n        'user_id', v_user_id,\r\n        'franquia_id', p_franquia_id,\r\n        'email', p_email\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'sucesso', false,\r\n        'mensagem', 'Erro ao criar usuário para franquia: ' || SQLERRM,\r\n        'codigo', 'ERRO_INTERNO',\r\n        'sqlstate', SQLSTATE\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_usuario_franquia(p_franquia_id uuid, p_email character varying, p_senha character varying, p_nome character varying DEFAULT NULL::character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_franquia_nome VARCHAR;\r\n    v_email VARCHAR;\r\nBEGIN\r\n    -- Verificar se a franquia existe\r\n    IF NOT EXISTS (SELECT 1 FROM public.franquias WHERE id = p_franquia_id) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Franquia não encontrada'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se já existe um usuário com o mesmo email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe um usuário com este email'\r\n        );\r\n    END IF;\r\n\r\n    -- Obter informações da franquia\r\n    SELECT nome, email \r\n    INTO v_franquia_nome, v_email\r\n    FROM public.franquias \r\n    WHERE id = p_franquia_id;\r\n\r\n    -- Se o nome do responsável não foi fornecido, usar o nome da franquia\r\n    IF p_nome IS NULL OR p_nome = '' THEN\r\n        p_nome := v_franquia_nome;\r\n    END IF;\r\n\r\n    -- Utilizar o email da franquia se não for fornecido\r\n    IF p_email IS NULL OR p_email = '' THEN\r\n        p_email := v_email;\r\n    END IF;\r\n\r\n    -- Criar o usuário\r\n    INSERT INTO auth.users (\r\n        email,\r\n        encrypted_password,\r\n        email_confirmed_at,\r\n        raw_app_meta_data,\r\n        raw_user_meta_data\r\n    ) VALUES (\r\n        p_email,\r\n        crypt(p_senha, gen_salt('bf')),\r\n        now(),\r\n        '{\"provider\":\"email\",\"providers\":[\"email\"],\"role\":\"franquia\"}'::jsonb,\r\n        jsonb_build_object('nome', p_nome)\r\n    )\r\n    RETURNING id INTO v_user_id;\r\n\r\n    -- Atualizar user_id na franquia (de forma segura)\r\n    BEGIN\r\n        UPDATE public.franquias\r\n        SET user_id = v_user_id\r\n        WHERE id = p_franquia_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        -- Se falhar ao atualizar franquia, ainda retornar sucesso na criação do usuário\r\n        RETURN jsonb_build_object(\r\n            'sucesso', true,\r\n            'mensagem', 'Usuário criado, mas não foi possível associá-lo à franquia',\r\n            'user_id', v_user_id,\r\n            'franquia_id', p_franquia_id\r\n        );\r\n    END;\r\n\r\n    RETURN jsonb_build_object(\r\n        'sucesso', true,\r\n        'mensagem', 'Usuário da franquia criado com sucesso',\r\n        'user_id', v_user_id,\r\n        'franquia_id', p_franquia_id\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'sucesso', false,\r\n        'mensagem', 'Erro ao criar usuário para franquia: ' || SQLERRM\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.gerar_relatorio_licitacoes_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone, p_status text DEFAULT NULL::text, p_cliente_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN relatorio_licitacoes_v3(p_data_inicio, p_data_fim, p_status, p_cliente_id);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  RETURN auth.role() = 'authenticated' AND (\r\n    current_setting('request.jwt.claims', true)::json->>'email' = 'admin@licitagora.com'\r\n    OR coalesce(current_setting('request.jwt.claims', true)::json->'app_metadata'->>'role', '') = 'admin'\r\n  );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.is_franquia()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    RETURN EXISTS (\r\n        SELECT 1 FROM auth.users\r\n        WHERE id = auth.uid() \r\n        AND raw_app_meta_data->>'role' = 'franquia'\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.executar_sql_personalizado(p_sql text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_resultado jsonb;\r\n    v_erro text;\r\nBEGIN\r\n    -- Registrar a execução para auditoria\r\n    INSERT INTO log_execucao_sql (sql_executado, usuario)\r\n    VALUES (p_sql, current_user);\r\n    \r\n    BEGIN\r\n        EXECUTE p_sql INTO v_resultado;\r\n        RETURN jsonb_build_object('sucesso', true, 'resultado', v_resultado);\r\n    EXCEPTION WHEN OTHERS THEN\r\n        GET STACKED DIAGNOSTICS v_erro = PG_EXCEPTION_DETAIL;\r\n        \r\n        -- Registrar o erro\r\n        UPDATE log_execucao_sql \r\n        SET erro = v_erro\r\n        WHERE id = (SELECT max(id) FROM log_execucao_sql WHERE usuario = current_user);\r\n        \r\n        RETURN jsonb_build_object('sucesso', false, 'erro', SQLERRM, 'detalhe', v_erro);\r\n    END;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.get_user_franquia_id()\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_franquia_id UUID;\r\nBEGIN\r\n    SELECT id INTO v_franquia_id\r\n    FROM public.franquias\r\n    WHERE user_id = auth.uid();\r\n    \r\n    RETURN v_franquia_id;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.executar_sql(p_sql text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_result JSONB;\r\nBEGIN\r\n    EXECUTE p_sql;\r\n    RETURN jsonb_build_object('success', true);\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object('success', false, 'error', SQLERRM);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.processar_requisitos_edital(p_texto text, p_licitacao_id uuid)\n RETURNS SETOF requisito_result\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_linha TEXT;\r\n    v_texto_requisito TEXT := '';\r\n    v_capturando_requisitos BOOLEAN := false;\r\n    v_contador INTEGER := 0;\r\n    v_secao_atual TEXT := '';\r\n    v_subsecao_atual TEXT := '';\r\n    v_categoria_atual TEXT := '';\r\n    v_linhas TEXT[];\r\n    v_resultado requisito_result;\r\n    v_prazo_validade TEXT := '';\r\n    v_ultima_linha_numerada TEXT := '';\r\n    v_ultimo_numero TEXT := '';\r\n    v_max_ordem INTEGER;\r\nBEGIN\r\n    -- Verificar se a licitação existe\r\n    IF NOT EXISTS (SELECT 1 FROM licitacoes WHERE id = p_licitacao_id) THEN\r\n        RAISE EXCEPTION 'Licitação não encontrada';\r\n    END IF;\r\n\r\n    -- Excluir requisitos existentes para esta licitação\r\n    DELETE FROM requisitos_documentacao WHERE licitacao_id = p_licitacao_id;\r\n    \r\n    -- Iniciar contador de ordem\r\n    v_contador := 1;\r\n\r\n    -- Dividir o texto em linhas e limpar espaços extras\r\n    v_linhas := string_to_array(p_texto, E'\\n');\r\n    \r\n    -- Processar linha por linha\r\n    FOR i IN 1..array_length(v_linhas, 1) LOOP\r\n        -- Limpar a linha atual\r\n        v_linha := trim(regexp_replace(v_linhas[i], '\\s+', ' ', 'g'));\r\n        \r\n        -- Pular linhas vazias\r\n        CONTINUE WHEN length(v_linha) < 3;\r\n        \r\n        -- Identificar seções principais de habilitação\r\n        IF v_linha ~* '(HABILITAÇÃO|DOCUMENTOS DE HABILITAÇÃO|DOCUMENTAÇÃO PARA HABILITAÇÃO|DOCUMENTOS NECESSÁRIOS|REQUISITOS)' THEN\r\n            v_capturando_requisitos := true;\r\n            v_secao_atual := v_linha;\r\n            CONTINUE;\r\n        END IF;\r\n\r\n        -- Identificar subseções de habilitação\r\n        IF v_capturando_requisitos AND v_linha ~* '(Habilitação Jurídica|Regularidade Fiscal|Qualificação Técnica|Qualificação Econômico.Financeira|Declarações|MICROEMPRESA.*ME|EMPRESA DE PEQUENO PORTE.*EPP)' THEN\r\n            v_subsecao_atual := v_linha;\r\n            -- Extrair categoria principal\r\n            v_categoria_atual := CASE \r\n                WHEN v_linha ~* 'Jurídica' THEN 'JURIDICA'\r\n                WHEN v_linha ~* 'Fiscal' THEN 'FISCAL'\r\n                WHEN v_linha ~* 'Técnica' THEN 'TECNICA'\r\n                WHEN v_linha ~* 'Econômico.Financeira' THEN 'FINANCEIRA'\r\n                WHEN v_linha ~* 'Declarações' THEN 'DECLARACOES'\r\n                WHEN v_linha ~* '(MICROEMPRESA|ME|EPP)' THEN 'ME_EPP'\r\n                ELSE 'OUTROS'\r\n            END;\r\n            CONTINUE;\r\n        END IF;\r\n\r\n        -- Capturar prazo de validade se mencionado\r\n        IF v_linha ~* '(prazo.*validade|válido.*por|dentro.*prazo).*(\\d+).*dias' THEN\r\n            v_prazo_validade := regexp_replace(v_linha, '.*?(\\d+).*dias.*', '\\1 dias', 'i');\r\n        END IF;\r\n\r\n        -- Identificar fim de seção\r\n        IF v_linha ~* '(PROPOSTA|PREÇO|PAGAMENTO|DISPOSIÇÕES FINAIS|ANEXO|ENCERRAMENTO)' AND v_capturando_requisitos THEN\r\n            v_capturando_requisitos := false;\r\n            v_secao_atual := '';\r\n            v_subsecao_atual := '';\r\n            v_categoria_atual := '';\r\n        END IF;\r\n\r\n        -- Processar linha se estiver capturando requisitos\r\n        IF v_capturando_requisitos AND length(v_linha) > 5 THEN\r\n            -- Extrair número do item se presente\r\n            IF v_linha ~* '^(\\d+\\.[\\d\\.]*|\\([a-z]\\))' THEN\r\n                v_ultimo_numero := regexp_replace(v_linha, '^((\\d+\\.[\\d\\.]*|\\([a-z]\\))).*', '\\1');\r\n                v_ultima_linha_numerada := v_linha;\r\n            END IF;\r\n\r\n            -- Identificar padrões comuns de requisitos\r\n            IF v_linha ~* '^(\\d+\\.[\\d\\.]*|\\([a-z]\\)|\\-|\\•|[a-z]\\.|\\[\\d+\\]|[IVX]+\\.)' OR  -- Vários tipos de numeração/bullets\r\n               v_linha ~* '^(apresentar|fornecer|comprovar|demonstrar|possuir|prova)' OR  -- Verbos comuns\r\n               v_linha ~* '(certidão|atestado|declaração|comprovante|documento|registro|inscrição|alvará|licença)' OR  -- Documentos comuns\r\n               v_linha ~* '^(cópia|certificado)' OR  -- Outros indicadores de requisitos\r\n               v_linha ~* '(ME|EPP|Microempresa|Empresa de Pequeno Porte).*dever[áã]' THEN  -- Requisitos específicos ME/EPP\r\n                \r\n                -- Verificar se é continuação do último item numerado\r\n                IF v_ultimo_numero != '' AND \r\n                   NOT v_linha ~* '^(\\d+\\.[\\d\\.]*|\\([a-z]\\)|\\-|\\•|[a-z]\\.|\\[\\d+\\]|[IVX]+\\.)' AND\r\n                   (\r\n                       v_linha ~* '^(e|ou|para|quando|no caso|em caso|conforme|mediante|desde que|sendo|onde|que|com)'\r\n                       OR v_linha ~* '^[a-z]'  -- Começa com letra minúscula\r\n                       OR length(v_texto_requisito) = 0  -- Primeira linha após número\r\n                   ) THEN\r\n                    -- É continuação do item anterior\r\n                    IF length(v_texto_requisito) = 0 THEN\r\n                        v_texto_requisito := v_ultima_linha_numerada;\r\n                    END IF;\r\n                    v_texto_requisito := v_texto_requisito || ' ' || v_linha;\r\n                ELSE\r\n                    -- Se já tiver um requisito acumulado, inserir\r\n                    IF length(v_texto_requisito) > 0 THEN\r\n                        -- Limpar o requisito\r\n                        v_texto_requisito := regexp_replace(v_texto_requisito, '^\\W+', ''); -- Remove caracteres especiais do início\r\n                        v_texto_requisito := regexp_replace(v_texto_requisito, '\\s+', ' '); -- Normaliza espaços\r\n                        \r\n                        -- Inserir o requisito\r\n                        WITH inserted AS (\r\n                            INSERT INTO requisitos_documentacao (\r\n                                licitacao_id,\r\n                                descricao,\r\n                                observacoes,\r\n                                atendido,\r\n                                ordem\r\n                            ) VALUES (\r\n                                p_licitacao_id,\r\n                                trim(v_texto_requisito),\r\n                                CASE \r\n                                    WHEN v_subsecao_atual != '' THEN \r\n                                        'Categoria: ' || v_categoria_atual || \r\n                                        E'\\nSeção: ' || v_secao_atual || \r\n                                        E'\\nSubseção: ' || v_subsecao_atual ||\r\n                                        CASE \r\n                                            WHEN v_prazo_validade != '' THEN E'\\nPrazo de Validade: ' || v_prazo_validade\r\n                                            ELSE ''\r\n                                        END\r\n                                    ELSE \r\n                                        'Seção: ' || v_secao_atual ||\r\n                                        CASE \r\n                                            WHEN v_prazo_validade != '' THEN E'\\nPrazo de Validade: ' || v_prazo_validade\r\n                                            ELSE ''\r\n                                        END\r\n                                END,\r\n                                false,\r\n                                v_contador\r\n                            )\r\n                            RETURNING requisitos_documentacao.*\r\n                        )\r\n                        SELECT \r\n                            inserted.id,\r\n                            inserted.licitacao_id,\r\n                            inserted.descricao,\r\n                            inserted.observacoes,\r\n                            inserted.atendido,\r\n                            inserted.ordem,\r\n                            inserted.created_at,\r\n                            inserted.updated_at\r\n                        INTO v_resultado\r\n                        FROM inserted;\r\n\r\n                        RETURN NEXT v_resultado;\r\n                        v_contador := v_contador + 1;\r\n                    END IF;\r\n                    \r\n                    -- Iniciar novo requisito\r\n                    v_texto_requisito := v_linha;\r\n                END IF;\r\n            ELSE\r\n                -- Verificar se é continuação do requisito atual\r\n                IF length(v_texto_requisito) > 0 AND length(v_linha) > 0 THEN\r\n                    -- Verificar se a linha parece ser uma continuação natural\r\n                    IF v_linha ~* '^(e|ou|para|quando|no caso|em caso|conforme|mediante|desde que|sendo|onde|que|com)' OR\r\n                       v_linha ~* '^[a-z]' OR  -- Começa com letra minúscula\r\n                       NOT v_linha ~* '^(\\d+\\.|\\(|\\-|\\•|[a-z]\\.|\\[\\d+\\]|[IVX]+\\.)' THEN\r\n                        v_texto_requisito := v_texto_requisito || ' ' || v_linha;\r\n                    END IF;\r\n                END IF;\r\n            END IF;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    -- Inserir último requisito se houver\r\n    IF length(v_texto_requisito) > 0 THEN\r\n        -- Limpar o requisito\r\n        v_texto_requisito := regexp_replace(v_texto_requisito, '^\\W+', ''); -- Remove caracteres especiais do início\r\n        v_texto_requisito := regexp_replace(v_texto_requisito, '\\s+', ' '); -- Normaliza espaços\r\n        \r\n        WITH inserted AS (\r\n            INSERT INTO requisitos_documentacao (\r\n                licitacao_id,\r\n                descricao,\r\n                observacoes,\r\n                atendido,\r\n                ordem\r\n            ) VALUES (\r\n                p_licitacao_id,\r\n                trim(v_texto_requisito),\r\n                CASE \r\n                    WHEN v_subsecao_atual != '' THEN \r\n                        'Categoria: ' || v_categoria_atual || \r\n                        E'\\nSeção: ' || v_secao_atual || \r\n                        E'\\nSubseção: ' || v_subsecao_atual ||\r\n                        CASE \r\n                            WHEN v_prazo_validade != '' THEN E'\\nPrazo de Validade: ' || v_prazo_validade\r\n                            ELSE ''\r\n                        END\r\n                    ELSE \r\n                        'Seção: ' || v_secao_atual ||\r\n                        CASE \r\n                            WHEN v_prazo_validade != '' THEN E'\\nPrazo de Validade: ' || v_prazo_validade\r\n                            ELSE ''\r\n                        END\r\n                END,\r\n                false,\r\n                v_contador\r\n            )\r\n            RETURNING requisitos_documentacao.*\r\n        )\r\n        SELECT \r\n            inserted.id,\r\n            inserted.licitacao_id,\r\n            inserted.descricao,\r\n            inserted.observacoes,\r\n            inserted.atendido,\r\n            inserted.ordem,\r\n            inserted.created_at,\r\n            inserted.updated_at\r\n        INTO v_resultado\r\n        FROM inserted;\r\n\r\n        RETURN NEXT v_resultado;\r\n    END IF;\r\n\r\n    -- Se nenhum requisito foi encontrado, adicionar uma mensagem\r\n    IF v_contador = 1 THEN\r\n        WITH inserted AS (\r\n            INSERT INTO requisitos_documentacao (\r\n                licitacao_id,\r\n                descricao,\r\n                observacoes,\r\n                atendido,\r\n                ordem\r\n            ) VALUES (\r\n                p_licitacao_id,\r\n                'Não foi possível extrair requisitos automaticamente',\r\n                'Recomendamos adicionar os requisitos manualmente ou verificar o formato do edital.',\r\n                false,\r\n                0\r\n            )\r\n            RETURNING requisitos_documentacao.*\r\n        )\r\n        SELECT \r\n            inserted.id,\r\n            inserted.licitacao_id,\r\n            inserted.descricao,\r\n            inserted.observacoes,\r\n            inserted.atendido,\r\n            inserted.ordem,\r\n            inserted.created_at,\r\n            inserted.updated_at\r\n        INTO v_resultado\r\n        FROM inserted;\r\n\r\n        RETURN NEXT v_resultado;\r\n    END IF;\r\n\r\n    RETURN;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n\n\nCREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n    BEGIN\n        NEW.updated_at = CURRENT_TIMESTAMP;\n        RETURN NEW;\n    END;\n    $function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_colunas_franquias()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Remover a coluna responsavel se existir\r\n    BEGIN\r\n        EXECUTE 'ALTER TABLE public.franquias DROP COLUMN IF EXISTS responsavel;';\r\n    EXCEPTION \r\n        WHEN undefined_column OR undefined_table OR invalid_column_reference OR duplicate_column THEN\r\n            -- Ignora se a coluna não existir\r\n            NULL;\r\n    END;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_tabela_existe(p_schema text, p_table_name text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_exists BOOLEAN;\r\nBEGIN\r\n    SELECT EXISTS (\r\n        SELECT 1 \r\n        FROM pg_tables\r\n        WHERE schemaname = p_schema\r\n        AND tablename = p_table_name\r\n    ) INTO v_exists;\r\n    \r\n    RETURN jsonb_build_object('exists', v_exists);\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object('exists', false, 'error', SQLERRM);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_permissao_usuario(p_user_id uuid, p_codigo_permissao character varying)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_tipo tipo_usuario;\r\n    v_franquia_id UUID;\r\n    v_cliente_id UUID;\r\n    v_permissao_id UUID;\r\n    v_tem_permissao BOOLEAN := FALSE;\r\nBEGIN\r\n    -- Obter o tipo de usuário\r\n    SELECT tipo INTO v_tipo FROM public.perfis_usuario WHERE user_id = p_user_id;\r\n    \r\n    -- Se não encontrou perfil, retorna falso\r\n    IF v_tipo IS NULL THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Obter ID da permissão\r\n    SELECT id INTO v_permissao_id FROM public.permissoes WHERE codigo = p_codigo_permissao;\r\n    \r\n    -- Se não encontrou permissão, retorna falso\r\n    IF v_permissao_id IS NULL THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Verificar permissão por tipo de usuário\r\n    SELECT ativo INTO v_tem_permissao \r\n    FROM public.permissoes_tipo_usuario \r\n    WHERE tipo_usuario = v_tipo AND permissao_id = v_permissao_id;\r\n    \r\n    -- Se tem permissão por tipo, retorna verdadeiro\r\n    IF v_tem_permissao = TRUE THEN\r\n        RETURN TRUE;\r\n    END IF;\r\n    \r\n    -- Se for franquia, verificar permissões personalizadas\r\n    IF v_tipo = 'FRANQUIA' THEN\r\n        SELECT id INTO v_franquia_id FROM public.franquias WHERE user_id = p_user_id;\r\n        \r\n        IF v_franquia_id IS NOT NULL THEN\r\n            SELECT ativo INTO v_tem_permissao \r\n            FROM public.permissoes_franquia \r\n            WHERE franquia_id = v_franquia_id AND permissao_id = v_permissao_id;\r\n            \r\n            IF v_tem_permissao = TRUE THEN\r\n                RETURN TRUE;\r\n            END IF;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Se for cliente, verificar permissões personalizadas\r\n    IF v_tipo = 'CLIENTE' THEN\r\n        SELECT id INTO v_cliente_id FROM public.clientes WHERE user_id = p_user_id;\r\n        \r\n        IF v_cliente_id IS NOT NULL THEN\r\n            SELECT ativo INTO v_tem_permissao \r\n            FROM public.permissoes_cliente \r\n            WHERE cliente_id = v_cliente_id AND permissao_id = v_permissao_id;\r\n            \r\n            IF v_tem_permissao = TRUE THEN\r\n                RETURN TRUE;\r\n            END IF;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_funcao_existe(p_schema text, p_function_name text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_exists BOOLEAN;\r\nBEGIN\r\n    SELECT EXISTS (\r\n        SELECT 1 \r\n        FROM pg_proc p\r\n        JOIN pg_namespace n ON p.pronamespace = n.oid\r\n        WHERE n.nspname = p_schema\r\n        AND p.proname = p_function_name\r\n    ) INTO v_exists;\r\n    \r\n    RETURN jsonb_build_object('exists', v_exists);\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object('exists', false, 'error', SQLERRM);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n\n\nCREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n\n\nCREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n\n\nCREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION public.adicionar_requisitos_teste(p_licitacao_id uuid)\n RETURNS SETOF requisitos_documentacao\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_max_ordem INTEGER;\r\nBEGIN\r\n    -- Verificar se a licitação existe\r\n    IF NOT EXISTS (SELECT 1 FROM licitacoes WHERE id = p_licitacao_id) THEN\r\n        RAISE EXCEPTION 'Licitação com ID % não encontrada', p_licitacao_id;\r\n    END IF;\r\n\r\n    -- Obter a ordem máxima atual\r\n    SELECT COALESCE(MAX(ordem), 0) INTO v_max_ordem FROM requisitos_documentacao WHERE licitacao_id = p_licitacao_id;\r\n    \r\n    -- Inserir requisitos de teste\r\n    RETURN QUERY\r\n    WITH inserted AS (\r\n        INSERT INTO requisitos_documentacao (\r\n            licitacao_id,\r\n            descricao,\r\n            observacoes,\r\n            atendido,\r\n            ordem\r\n        ) VALUES \r\n        (\r\n            p_licitacao_id,\r\n            'Certidão Negativa de Débitos Federais',\r\n            'Categoria: FISCAL\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Regularidade Fiscal\r\nPrazo de Validade: 30 dias',\r\n            false,\r\n            v_max_ordem + 1\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Certidão Negativa de Débitos Estaduais',\r\n            'Categoria: FISCAL\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Regularidade Fiscal\r\nPrazo de Validade: 30 dias',\r\n            false,\r\n            v_max_ordem + 2\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Certidão Negativa de Débitos Municipais',\r\n            'Categoria: FISCAL\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Regularidade Fiscal\r\nPrazo de Validade: 30 dias',\r\n            false,\r\n            v_max_ordem + 3\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Certidão Negativa de Débitos Trabalhistas',\r\n            'Categoria: FISCAL\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Regularidade Fiscal\r\nPrazo de Validade: 30 dias',\r\n            false,\r\n            v_max_ordem + 4\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Certificado de Regularidade do FGTS',\r\n            'Categoria: FISCAL\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Regularidade Fiscal\r\nPrazo de Validade: 30 dias',\r\n            false,\r\n            v_max_ordem + 5\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Contrato Social ou Estatuto',\r\n            'Categoria: JURIDICA\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Habilitação Jurídica',\r\n            false,\r\n            v_max_ordem + 6\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Atestado de Capacidade Técnica',\r\n            'Categoria: TECNICA\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Qualificação Técnica',\r\n            false,\r\n            v_max_ordem + 7\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Balanço Patrimonial',\r\n            'Categoria: FINANCEIRA\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Qualificação Econômico-Financeira',\r\n            false,\r\n            v_max_ordem + 8\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Declaração de que não emprega menor',\r\n            'Categoria: DECLARACOES\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Declarações',\r\n            false,\r\n            v_max_ordem + 9\r\n        ),\r\n        (\r\n            p_licitacao_id,\r\n            'Declaração de inexistência de fato impeditivo',\r\n            'Categoria: DECLARACOES\r\nSeção: DOCUMENTOS DE HABILITAÇÃO\r\nSubseção: Declarações',\r\n            false,\r\n            v_max_ordem + 10\r\n        )\r\n        RETURNING *\r\n    )\r\n    SELECT * FROM inserted;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.atualizar_tabela_requisitos()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Verificar se a tabela existe\r\n    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao') THEN\r\n        -- Criar a tabela se não existir\r\n        CREATE TABLE public.requisitos_documentacao (\r\n            id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\r\n            licitacao_id UUID NOT NULL REFERENCES public.licitacoes(id) ON DELETE CASCADE,\r\n            descricao TEXT NOT NULL,\r\n            observacoes TEXT,\r\n            atendido BOOLEAN DEFAULT false,\r\n            ordem INTEGER DEFAULT 0,\r\n            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\r\n        );\r\n    ELSE\r\n        -- Garantir que todas as colunas necessárias existam\r\n        -- Adicionar coluna observacoes se não existir\r\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns \r\n                      WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                      AND column_name = 'observacoes') THEN\r\n            ALTER TABLE public.requisitos_documentacao ADD COLUMN observacoes TEXT;\r\n        END IF;\r\n\r\n        -- Adicionar coluna atendido se não existir\r\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns \r\n                      WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                      AND column_name = 'atendido') THEN\r\n            ALTER TABLE public.requisitos_documentacao ADD COLUMN atendido BOOLEAN DEFAULT false;\r\n        END IF;\r\n\r\n        -- Adicionar coluna ordem se não existir\r\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns \r\n                      WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                      AND column_name = 'ordem') THEN\r\n            ALTER TABLE public.requisitos_documentacao ADD COLUMN ordem INTEGER DEFAULT 0;\r\n        END IF;\r\n\r\n        -- Remover colunas que não são mais necessárias\r\n        -- Remover tipo_documento_id se existir e não for mais necessária\r\n        IF EXISTS (SELECT 1 FROM information_schema.columns \r\n                  WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                  AND column_name = 'tipo_documento_id') THEN\r\n            ALTER TABLE public.requisitos_documentacao DROP COLUMN tipo_documento_id CASCADE;\r\n        END IF;\r\n\r\n        -- Remover data_limite se existir e não for mais necessária\r\n        IF EXISTS (SELECT 1 FROM information_schema.columns \r\n                  WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                  AND column_name = 'data_limite') THEN\r\n            ALTER TABLE public.requisitos_documentacao DROP COLUMN data_limite CASCADE;\r\n        END IF;\r\n\r\n        -- Remover obrigatorio se existir e não for mais necessário\r\n        IF EXISTS (SELECT 1 FROM information_schema.columns \r\n                  WHERE table_schema = 'public' AND table_name = 'requisitos_documentacao' \r\n                  AND column_name = 'obrigatorio') THEN\r\n            ALTER TABLE public.requisitos_documentacao DROP COLUMN obrigatorio CASCADE;\r\n        END IF;\r\n\r\n        -- Remover constraint que não é mais necessária\r\n        BEGIN\r\n            ALTER TABLE public.requisitos_documentacao DROP CONSTRAINT IF EXISTS uk_licitacao_tipo_doc;\r\n        EXCEPTION WHEN OTHERS THEN\r\n            -- Ignora erro se a constraint não existir\r\n            NULL;\r\n        END;\r\n    END IF;\r\n\r\n    -- Criar índices necessários\r\n    CREATE INDEX IF NOT EXISTS idx_requisitos_licitacao ON public.requisitos_documentacao(licitacao_id);\r\n    CREATE INDEX IF NOT EXISTS idx_requisitos_ordem ON public.requisitos_documentacao(ordem);\r\n\r\n    -- Criar trigger para atualizar o campo updated_at\r\n    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_requisitos_documentacao_updated_at') THEN\r\n        CREATE TRIGGER update_requisitos_documentacao_updated_at\r\n        BEFORE UPDATE ON public.requisitos_documentacao\r\n        FOR EACH ROW\r\n        EXECUTE FUNCTION update_updated_at_column();\r\n    END IF;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_documentos_vencimento(p_dias_alerta integer DEFAULT 30)\n RETURNS TABLE(id uuid, nome character varying, tipo_documento_id uuid, tipo_documento_nome character varying, data_validade timestamp with time zone, dias_para_vencer integer, cliente_id uuid, cliente_razao_social character varying, licitacao_id uuid, licitacao_numero character varying)\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT \r\n        d.id,\r\n        d.nome,\r\n        d.tipo_documento_id,\r\n        td.nome as tipo_documento_nome,\r\n        d.data_validade,\r\n        EXTRACT(DAY FROM (d.data_validade - CURRENT_TIMESTAMP))::INTEGER as dias_para_vencer,\r\n        c.id as cliente_id,\r\n        c.razao_social as cliente_razao_social,\r\n        NULL::UUID as licitacao_id,\r\n        NULL::VARCHAR as licitacao_numero\r\n    FROM documentos_cliente d\r\n    JOIN clientes c ON c.id = d.cliente_id\r\n    JOIN tipos_documentos td ON td.id = d.tipo_documento_id\r\n    WHERE \r\n        d.data_validade IS NOT NULL \r\n        AND d.data_validade <= (CURRENT_TIMESTAMP + (p_dias_alerta || ' days')::INTERVAL)\r\n    UNION ALL\r\n    SELECT \r\n        d.id,\r\n        d.nome,\r\n        d.tipo_documento_id,\r\n        td.nome as tipo_documento_nome,\r\n        d.data_validade,\r\n        EXTRACT(DAY FROM (d.data_validade - CURRENT_TIMESTAMP))::INTEGER as dias_para_vencer,\r\n        NULL::UUID as cliente_id,\r\n        NULL::VARCHAR as cliente_razao_social,\r\n        l.id as licitacao_id,\r\n        l.numero as licitacao_numero\r\n    FROM documentos_licitacao d\r\n    JOIN licitacoes l ON l.id = d.licitacao_id\r\n    JOIN tipos_documentos td ON td.id = d.tipo_documento_id\r\n    WHERE \r\n        d.data_validade IS NOT NULL \r\n        AND d.data_validade <= (CURRENT_TIMESTAMP + (p_dias_alerta || ' days')::INTERVAL)\r\n    ORDER BY dias_para_vencer;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.buscar_estatisticas()\n RETURNS TABLE(total_clientes bigint, total_licitacoes bigint, licitacoes_em_andamento bigint, licitacoes_concluidas bigint, documentos_proximos_vencimento bigint, prazos_proximos bigint, valor_total_licitacoes numeric)\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n    SELECT \r\n        (SELECT COUNT(*) FROM clientes) as total_clientes,\r\n        (SELECT COUNT(*) FROM licitacoes) as total_licitacoes,\r\n        (SELECT COUNT(*) FROM licitacoes WHERE status = 'EM_ANDAMENTO') as licitacoes_em_andamento,\r\n        (SELECT COUNT(*) FROM licitacoes WHERE status = 'CONCLUIDA') as licitacoes_concluidas,\r\n        (\r\n            SELECT COUNT(*) \r\n            FROM (\r\n                SELECT data_validade FROM documentos_cliente WHERE data_validade <= (CURRENT_TIMESTAMP + '30 days'::INTERVAL)\r\n                UNION ALL\r\n                SELECT data_validade FROM documentos_licitacao WHERE data_validade <= (CURRENT_TIMESTAMP + '30 days'::INTERVAL)\r\n            ) docs\r\n        ) as documentos_proximos_vencimento,\r\n        (\r\n            SELECT COUNT(*)\r\n            FROM prazos\r\n            WHERE data_prazo >= CURRENT_TIMESTAMP AND data_prazo <= (CURRENT_TIMESTAMP + '7 days'::INTERVAL)\r\n        ) as prazos_proximos,\r\n        (SELECT COALESCE(SUM(valor_estimado), 0) FROM licitacoes) as valor_total_licitacoes;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_cliente(p_nome text, p_email text, p_telefone text, p_cnpj text, p_endereco text, p_cidade text, p_estado text, p_cep text, p_matriz_id uuid, p_franquia_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user_id UUID;\r\n  v_cliente_id UUID;\r\nBEGIN\r\n  -- Verificar se o usuário matriz existe\r\n  IF NOT EXISTS (SELECT 1 FROM perfis_usuario WHERE user_id = p_matriz_id AND tipo = 'MATRIZ') THEN\r\n    RAISE EXCEPTION 'Usuário matriz não encontrado';\r\n  END IF;\r\n  \r\n  -- Verificar se a franquia existe (se fornecida)\r\n  IF p_franquia_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM franquias WHERE id = p_franquia_id) THEN\r\n    RAISE EXCEPTION 'Franquia não encontrada';\r\n  END IF;\r\n  \r\n  -- Criar o usuário no sistema de autenticação (se necessário)\r\n  -- Nota: Esta parte depende de como você está criando usuários no Supabase\r\n  -- Aqui estamos assumindo que você tem uma função ou procedimento para isso\r\n  \r\n  -- Inserir o cliente no banco de dados\r\n  INSERT INTO clientes (\r\n    nome, \r\n    email, \r\n    telefone, \r\n    cnpj, \r\n    endereco, \r\n    cidade, \r\n    estado, \r\n    cep, \r\n    matriz_id, \r\n    franquia_id, \r\n    data_vinculo,\r\n    created_at,\r\n    updated_at\r\n  ) VALUES (\r\n    p_nome,\r\n    p_email,\r\n    p_telefone,\r\n    p_cnpj,\r\n    p_endereco,\r\n    p_cidade,\r\n    p_estado,\r\n    p_cep,\r\n    p_matriz_id,\r\n    p_franquia_id,\r\n    NOW(),\r\n    NOW(),\r\n    NOW()\r\n  ) RETURNING id INTO v_cliente_id;\r\n  \r\n  RETURN v_cliente_id;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_franquia(p_nome text, p_cnpj text, p_email text, p_senha text, p_telefone text, p_endereco text, p_cidade text, p_estado text, p_cep text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_user_id UUID;\r\n  v_franquia_id UUID;\r\n  v_current_user_id UUID;\r\nBEGIN\r\n  -- Obter o ID do usuário atual (MATRIZ)\r\n  v_current_user_id := auth.uid();\r\n  \r\n  -- Verificar se o usuário atual tem permissão para criar franquias\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM perfis_usuario \r\n    WHERE user_id = v_current_user_id \r\n    AND tipo = 'MATRIZ'\r\n  ) THEN\r\n    RAISE EXCEPTION 'Usuário não tem permissão para criar franquias';\r\n  END IF;\r\n  \r\n  -- Criar o usuário no sistema de autenticação\r\n  INSERT INTO auth.users (email, encrypted_password, email_confirmed_at, raw_app_meta_data, raw_user_meta_data)\r\n  VALUES (\r\n    p_email,\r\n    crypt(p_senha, gen_salt('bf')),\r\n    NOW(),\r\n    '{\"provider\":\"email\",\"providers\":[\"email\"]}',\r\n    format('{\"nome\":\"%s\"}', p_nome)::jsonb\r\n  )\r\n  RETURNING id INTO v_user_id;\r\n  \r\n  -- Criar o perfil do usuário\r\n  INSERT INTO perfis_usuario (user_id, tipo, nome)\r\n  VALUES (v_user_id, 'FRANQUIA', p_nome);\r\n  \r\n  -- Criar a franquia\r\n  INSERT INTO franquias (\r\n    nome,\r\n    cnpj,\r\n    email,\r\n    telefone,\r\n    endereco,\r\n    cidade,\r\n    estado,\r\n    cep,\r\n    user_id,\r\n    created_at,\r\n    updated_at\r\n  )\r\n  VALUES (\r\n    p_nome,\r\n    p_cnpj,\r\n    p_email,\r\n    p_telefone,\r\n    p_endereco,\r\n    p_cidade,\r\n    p_estado,\r\n    p_cep,\r\n    v_user_id,\r\n    NOW(),\r\n    NOW()\r\n  )\r\n  RETURNING id INTO v_franquia_id;\r\n  \r\n  -- Retornar os dados da franquia criada\r\n  RETURN (\r\n    SELECT jsonb_build_object(\r\n      'id', f.id,\r\n      'nome', f.nome,\r\n      'email', f.email,\r\n      'user_id', f.user_id\r\n    )\r\n    FROM franquias f\r\n    WHERE f.id = v_franquia_id\r\n  );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_tabela_clientes()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    column_exists BOOLEAN;\r\nBEGIN\r\n    -- Criar a tabela se não existir\r\n    CREATE TABLE IF NOT EXISTS public.clientes (\r\n        id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\r\n        razao_social VARCHAR(200) NOT NULL,\r\n        cnpj VARCHAR(14) NOT NULL UNIQUE,\r\n        email VARCHAR(100) NOT NULL,\r\n        telefone VARCHAR(11),\r\n        cep VARCHAR(8),\r\n        endereco VARCHAR(200),\r\n        numero VARCHAR(20),\r\n        bairro VARCHAR(100),\r\n        cidade VARCHAR(100),\r\n        estado VARCHAR(2),\r\n        cnaes JSONB DEFAULT '[]'::JSONB,\r\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\r\n    );\r\n\r\n    -- Verificar se a coluna ramos_atividade ainda existe\r\n    SELECT EXISTS (\r\n        SELECT FROM information_schema.columns \r\n        WHERE table_name = 'clientes' AND column_name = 'ramos_atividade'\r\n    ) INTO column_exists;\r\n\r\n    -- Se a coluna ramos_atividade existir, migrar os dados para cnaes e remover a coluna\r\n    IF column_exists THEN\r\n        -- Migrar dados de ramos_atividade para cnaes\r\n        UPDATE public.clientes\r\n        SET cnaes = (\r\n            SELECT jsonb_agg(\r\n                jsonb_build_object(\r\n                    'codigo', '00.00-0-' || LPAD(ordinality::text, 2, '0'),\r\n                    'descricao', value,\r\n                    'tipo', CASE WHEN ordinality = 1 THEN 'principal' ELSE 'secundaria' END\r\n                )\r\n            )\r\n            FROM unnest(ramos_atividade) WITH ORDINALITY\r\n        )\r\n        WHERE ramos_atividade IS NOT NULL AND array_length(ramos_atividade, 1) > 0;\r\n\r\n        -- Remover a coluna ramos_atividade\r\n        ALTER TABLE public.clientes DROP COLUMN IF EXISTS ramos_atividade;\r\n    END IF;\r\n\r\n    -- Criar índices\r\n    CREATE INDEX IF NOT EXISTS idx_clientes_razao_social ON public.clientes(razao_social);\r\n    CREATE INDEX IF NOT EXISTS idx_clientes_cnpj ON public.clientes(cnpj);\r\n    CREATE INDEX IF NOT EXISTS idx_clientes_email ON public.clientes(email);\r\n    CREATE INDEX IF NOT EXISTS idx_clientes_cnaes ON public.clientes USING GIN (cnaes);\r\n\r\n    -- Remover trigger existente se houver\r\n    DROP TRIGGER IF EXISTS update_clientes_updated_at ON public.clientes;\r\n    \r\n    -- Criar novo trigger\r\n    CREATE TRIGGER update_clientes_updated_at\r\n        BEFORE UPDATE ON public.clientes\r\n        FOR EACH ROW\r\n        EXECUTE FUNCTION update_updated_at_column();\r\n\r\n    -- Remover política existente se houver\r\n    DROP POLICY IF EXISTS \"Permitir acesso total aos clientes\" ON public.clientes;\r\n    \r\n    -- Criar nova política\r\n    CREATE POLICY \"Permitir acesso total aos clientes\"\r\n    ON public.clientes\r\n    FOR ALL\r\n    USING (true)\r\n    WITH CHECK (true);\r\n\r\n    -- Habilitar RLS\r\n    ALTER TABLE public.clientes ENABLE ROW LEVEL SECURITY;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_tabela_franquias()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Criar a tabela se não existir\r\n    CREATE TABLE IF NOT EXISTS public.franquias (\r\n        id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\r\n        nome VARCHAR(200) NOT NULL,\r\n        cnpj VARCHAR(14) NOT NULL UNIQUE,\r\n        email VARCHAR(100) NOT NULL,\r\n        telefone VARCHAR(11),\r\n        cep VARCHAR(8),\r\n        endereco VARCHAR(200),\r\n        numero VARCHAR(20),\r\n        bairro VARCHAR(100),\r\n        cidade VARCHAR(100),\r\n        estado VARCHAR(2),\r\n        data_inicio TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n        ativa BOOLEAN DEFAULT true,\r\n        user_id UUID REFERENCES auth.users(id),\r\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\r\n    );\r\n\r\n    -- Garantir que a coluna user_id seja nullable\r\n    BEGIN\r\n        EXECUTE 'ALTER TABLE public.franquias ALTER COLUMN user_id DROP NOT NULL;';\r\n    EXCEPTION \r\n        WHEN undefined_column OR undefined_table OR invalid_column_reference THEN\r\n            -- Ignora se a coluna não existir ou já for nullable\r\n            NULL;\r\n    END;\r\n\r\n    -- Criar índices\r\n    CREATE INDEX IF NOT EXISTS idx_franquias_user_id ON public.franquias(user_id);\r\n    CREATE INDEX IF NOT EXISTS idx_franquias_ativa ON public.franquias(ativa);\r\n\r\n    -- Criar trigger para atualizar o timestamp\r\n    DROP TRIGGER IF EXISTS update_franquias_updated_at ON public.franquias;\r\n    CREATE TRIGGER update_franquias_updated_at\r\n    BEFORE UPDATE ON public.franquias\r\n    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();\r\n\r\n    -- Adicionar coluna de franquia_id na tabela de clientes se não existir\r\n    ALTER TABLE public.clientes \r\n    ADD COLUMN IF NOT EXISTS franquia_id UUID REFERENCES public.franquias(id);\r\n\r\n    -- Criar índice para a coluna franquia_id\r\n    CREATE INDEX IF NOT EXISTS idx_clientes_franquia_id ON public.clientes(franquia_id);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_tabela_health_check()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    -- Verificar se a tabela já existe\r\n    IF NOT EXISTS (\r\n        SELECT FROM pg_tables \r\n        WHERE schemaname = 'public' \r\n        AND tablename = 'health_check'\r\n    ) THEN\r\n        -- Criar a tabela de verificação de saúde\r\n        CREATE TABLE public.health_check (\r\n            id SERIAL PRIMARY KEY,\r\n            status TEXT DEFAULT 'ok',\r\n            last_check TIMESTAMPTZ DEFAULT NOW(),\r\n            details JSONB DEFAULT '{}'::jsonb\r\n        );\r\n        \r\n        -- Inserir um registro para verificações\r\n        INSERT INTO public.health_check (status, details)\r\n        VALUES ('ok', jsonb_build_object('message', 'Health check table created'));\r\n        \r\n        RAISE NOTICE 'Tabela health_check criada com sucesso';\r\n    ELSE\r\n        RAISE NOTICE 'Tabela health_check já existe';\r\n    END IF;\r\n    \r\n    -- Atualizar o registro mais recente para indicar que a verificação foi executada\r\n    UPDATE public.health_check\r\n    SET last_check = NOW(),\r\n        details = jsonb_build_object('message', 'Health check performed')\r\n    WHERE id = (SELECT MAX(id) FROM public.health_check);\r\n    \r\n    -- Limitar registros de verificação para evitar crescimento desnecessário\r\n    DELETE FROM public.health_check\r\n    WHERE id NOT IN (\r\n        SELECT id FROM public.health_check\r\n        ORDER BY last_check DESC\r\n        LIMIT 100\r\n    );\r\n    \r\n    RETURN TRUE;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Erro ao criar/atualizar tabela health_check: %', SQLERRM;\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_tabela_licitacoes()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Criar enum para status da licitação se não existir\r\n    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'status_licitacao') THEN\r\n        CREATE TYPE status_licitacao AS ENUM (\r\n            'EM_ANDAMENTO',\r\n            'CONCLUIDA',\r\n            'CANCELADA',\r\n            'SUSPENSA',\r\n            'FRACASSADA',\r\n            'DESERTA'\r\n        );\r\n    END IF;\r\n\r\n    -- Criar enum para modalidade se não existir\r\n    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'modalidade_licitacao') THEN\r\n        CREATE TYPE modalidade_licitacao AS ENUM (\r\n            'PREGAO_ELETRONICO',\r\n            'PREGAO_PRESENCIAL',\r\n            'CONCORRENCIA',\r\n            'TOMADA_DE_PRECOS',\r\n            'CONVITE',\r\n            'LEILAO',\r\n            'RDC',\r\n            'DISPENSA',\r\n            'INEXIGIBILIDADE'\r\n        );\r\n    END IF;\r\n\r\n    -- Criar a tabela se não existir\r\n    CREATE TABLE IF NOT EXISTS public.licitacoes (\r\n        id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\r\n        cliente_id UUID NOT NULL REFERENCES public.clientes(id) ON DELETE CASCADE,\r\n        numero VARCHAR(50) NOT NULL,\r\n        orgao VARCHAR(200) NOT NULL,\r\n        objeto TEXT NOT NULL,\r\n        modalidade modalidade_licitacao NOT NULL,\r\n        valor_estimado DECIMAL(15,2),\r\n        lucro_estimado DECIMAL(15,2),\r\n        valor_final DECIMAL(15,2),\r\n        lucro_final DECIMAL(15,2),\r\n        foi_ganha BOOLEAN,\r\n        motivo_perda TEXT,\r\n        data_fechamento TIMESTAMP WITH TIME ZONE,\r\n        data_abertura TIMESTAMP WITH TIME ZONE NOT NULL,\r\n        data_fim TIMESTAMP WITH TIME ZONE,\r\n        status status_licitacao NOT NULL DEFAULT 'EM_ANDAMENTO',\r\n        descricao TEXT,\r\n        requisitos TEXT,\r\n        observacoes TEXT,\r\n        ramos_atividade TEXT[],\r\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\r\n        CONSTRAINT uk_numero_orgao UNIQUE(numero, orgao)\r\n    );\r\n\r\n    -- Criar índices\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_cliente ON public.licitacoes(cliente_id);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_numero ON public.licitacoes(numero);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_status ON public.licitacoes(status);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_data_abertura ON public.licitacoes(data_abertura);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_modalidade ON public.licitacoes(modalidade);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_foi_ganha ON public.licitacoes(foi_ganha);\r\n    CREATE INDEX IF NOT EXISTS idx_licitacoes_data_fechamento ON public.licitacoes(data_fechamento);\r\n\r\n    -- Remover trigger existente se houver\r\n    DROP TRIGGER IF EXISTS update_licitacoes_updated_at ON public.licitacoes;\r\n    \r\n    -- Criar novo trigger\r\n    CREATE TRIGGER update_licitacoes_updated_at\r\n        BEFORE UPDATE ON public.licitacoes\r\n        FOR EACH ROW\r\n        EXECUTE FUNCTION update_updated_at_column();\r\n\r\n    -- Remover política existente se houver\r\n    DROP POLICY IF EXISTS \"Permitir acesso total as licitacoes\" ON public.licitacoes;\r\n    \r\n    -- Criar nova política\r\n    CREATE POLICY \"Permitir acesso total as licitacoes\"\r\n    ON public.licitacoes\r\n    FOR ALL\r\n    USING (true)\r\n    WITH CHECK (true);\r\n\r\n    -- Habilitar RLS\r\n    ALTER TABLE public.licitacoes ENABLE ROW LEVEL SECURITY;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_tabelas_documentos()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $functionx$\nBEGIN\n    -- Criar tipo enum para tipos de documentos\n    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'tipo_documento') THEN\n        CREATE TYPE tipo_documento AS ENUM (\n            'EDITAL',\n            'PROPOSTA',\n            'HABILITACAO',\n            'CONTRATO',\n            'ADITIVO',\n            'OUTROS'\n        );\n    END IF;\n\n    -- Criar tabela de tipos de documentos\n    CREATE TABLE IF NOT EXISTS public.tipos_documentos (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        nome VARCHAR(100) NOT NULL,\n        descricao TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- Criar tabela de documentos de cliente\n    CREATE TABLE IF NOT EXISTS public.documentos_cliente (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        cliente_id UUID NOT NULL REFERENCES public.clientes(id) ON DELETE CASCADE,\n        tipo_documento_id UUID NOT NULL REFERENCES public.tipos_documentos(id),\n        nome VARCHAR(255) NOT NULL,\n        arquivo_url TEXT NOT NULL,\n        data_validade TIMESTAMP WITH TIME ZONE,\n        observacoes TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- Criar tabela de documentos de licitação\n    CREATE TABLE IF NOT EXISTS public.documentos_licitacao (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        licitacao_id UUID NOT NULL REFERENCES public.licitacoes(id) ON DELETE CASCADE,\n        tipo_documento_id UUID NOT NULL REFERENCES public.tipos_documentos(id),\n        nome VARCHAR(255) NOT NULL,\n        arquivo_url TEXT NOT NULL,\n        data_validade TIMESTAMP WITH TIME ZONE,\n        observacoes TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- Criar tabela de requisitos de documentação\n    CREATE TABLE IF NOT EXISTS public.requisitos_documentacao (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        licitacao_id UUID NOT NULL REFERENCES public.licitacoes(id) ON DELETE CASCADE,\n        descricao TEXT NOT NULL,\n        atendido BOOLEAN DEFAULT FALSE,\n        observacoes TEXT,\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- Criar índices\n    CREATE INDEX IF NOT EXISTS idx_documentos_cliente_cliente_id ON public.documentos_cliente(cliente_id);\n    CREATE INDEX IF NOT EXISTS idx_documentos_cliente_tipo_documento_id ON public.documentos_cliente(tipo_documento_id);\n    CREATE INDEX IF NOT EXISTS idx_documentos_licitacao_licitacao_id ON public.documentos_licitacao(licitacao_id);\n    CREATE INDEX IF NOT EXISTS idx_documentos_licitacao_tipo_documento_id ON public.documentos_licitacao(tipo_documento_id);\n    CREATE INDEX IF NOT EXISTS idx_requisitos_documentacao_licitacao_id ON public.requisitos_documentacao(licitacao_id);\n\n    -- Criar triggers para atualização de timestamps\n    CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n    RETURNS trigger\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    AS $function$\n    BEGIN\n        NEW.updated_at = CURRENT_TIMESTAMP;\n        RETURN NEW;\n    END;\n    $function$;\n\n    -- Aplicar triggers\n    DROP TRIGGER IF EXISTS update_tipos_documentos_updated_at ON public.tipos_documentos;\n    CREATE TRIGGER update_tipos_documentos_updated_at\n        BEFORE UPDATE ON public.tipos_documentos\n        FOR EACH ROW\n        EXECUTE PROCEDURE public.update_updated_at_column();\n\n    DROP TRIGGER IF EXISTS update_documentos_cliente_updated_at ON public.documentos_cliente;\n    CREATE TRIGGER update_documentos_cliente_updated_at\n        BEFORE UPDATE ON public.documentos_cliente\n        FOR EACH ROW\n        EXECUTE PROCEDURE public.update_updated_at_column();\n\n    DROP TRIGGER IF EXISTS update_documentos_licitacao_updated_at ON public.documentos_licitacao;\n    CREATE TRIGGER update_documentos_licitacao_updated_at\n        BEFORE UPDATE ON public.documentos_licitacao\n        FOR EACH ROW\n        EXECUTE PROCEDURE public.update_updated_at_column();\n\n    DROP TRIGGER IF EXISTS update_requisitos_documentacao_updated_at ON public.requisitos_documentacao;\n    CREATE TRIGGER update_requisitos_documentacao_updated_at\n        BEFORE UPDATE ON public.requisitos_documentacao\n        FOR EACH ROW\n        EXECUTE PROCEDURE public.update_updated_at_column();\n\n    -- Criar políticas RLS\n    ALTER TABLE public.tipos_documentos ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.documentos_cliente ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.documentos_licitacao ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.requisitos_documentacao ENABLE ROW LEVEL SECURITY;\n\n    -- Políticas para tipos_documentos\n    DROP POLICY IF EXISTS \"Tipos documentos são visíveis para usuários autenticados\" ON public.tipos_documentos;\n    CREATE POLICY \"Tipos documentos são visíveis para usuários autenticados\"\n        ON public.tipos_documentos FOR ALL\n        TO authenticated\n        USING (true)\n        WITH CHECK (true);\n\n    -- Políticas para documentos_cliente\n    DROP POLICY IF EXISTS \"Documentos de cliente são visíveis para usuários autenticados\" ON public.documentos_cliente;\n    CREATE POLICY \"Documentos de cliente são visíveis para usuários autenticados\"\n        ON public.documentos_cliente FOR ALL\n        TO authenticated\n        USING (true)\n        WITH CHECK (true);\n\n    -- Políticas para documentos_licitacao\n    DROP POLICY IF EXISTS \"Documentos de licitação são visíveis para usuários autenticados\" ON public.documentos_licitacao;\n    CREATE POLICY \"Documentos de licitação são visíveis para usuários autenticados\"\n        ON public.documentos_licitacao FOR ALL\n        TO authenticated\n        USING (true)\n        WITH CHECK (true);\n\n    -- Políticas para requisitos_documentacao\n    DROP POLICY IF EXISTS \"Requisitos são visíveis para usuários autenticados\" ON public.requisitos_documentacao;\n    CREATE POLICY \"Requisitos são visíveis para usuários autenticados\"\n        ON public.requisitos_documentacao FOR ALL\n        TO authenticated\n        USING (true)\n        WITH CHECK (true);\nEND;\n$functionx$\n\n\nCREATE OR REPLACE FUNCTION public.criar_usuario_franquia(p_franquia_id uuid, p_email text, p_senha text, p_nome text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_user_id UUID;\r\n  v_result JSON;\r\nBEGIN\r\n  -- Tentar encontrar um usuário existente com este email\r\n  SELECT id INTO v_user_id FROM auth.users WHERE email = p_email;\r\n  \r\n  -- Se não encontrou, criar o usuário\r\n  IF v_user_id IS NULL THEN\r\n    -- Criar o usuário no auth.users\r\n    INSERT INTO auth.users (\r\n      email,\r\n      raw_user_meta_data,\r\n      raw_app_meta_data,\r\n      email_confirmed_at,\r\n      created_at,\r\n      updated_at,\r\n      last_sign_in_at,\r\n      confirmation_token,\r\n      recovery_token,\r\n      email_change_token_new,\r\n      email_change_token_current,\r\n      encrypted_password\r\n    ) VALUES (\r\n      p_email,\r\n      jsonb_build_object('nome', p_nome, 'tipo', 'franquia'),\r\n      jsonb_build_object('role', 'franquia'),\r\n      now(),\r\n      now(),\r\n      now(),\r\n      NULL,\r\n      '',\r\n      '',\r\n      '',\r\n      '',\r\n      crypt(p_senha, gen_salt('bf'))\r\n    ) RETURNING id INTO v_user_id;\r\n    \r\n    -- Adicionar o usuário ao auth.identities\r\n    INSERT INTO auth.identities (\r\n      id,\r\n      user_id,\r\n      identity_data,\r\n      provider,\r\n      created_at,\r\n      updated_at,\r\n      last_sign_in_at\r\n    ) VALUES (\r\n      v_user_id,\r\n      v_user_id,\r\n      jsonb_build_object('sub', v_user_id::text, 'email', p_email),\r\n      'email',\r\n      now(),\r\n      now(),\r\n      now()\r\n    );\r\n  END IF;\r\n  \r\n  -- Atualizar a franquia com o user_id\r\n  IF v_user_id IS NOT NULL THEN\r\n    UPDATE public.franquias SET user_id = v_user_id WHERE id = p_franquia_id;\r\n  END IF;\r\n  \r\n  RETURN json_build_object(\r\n    'success', v_user_id IS NOT NULL,\r\n    'user_id', v_user_id\r\n  );\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.criar_usuario_para_franquia(p_franquia_id uuid, p_email character varying, p_senha character varying, p_nome character varying DEFAULT NULL::character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_franquia_nome VARCHAR;\r\n    v_email VARCHAR;\r\nBEGIN\r\n    -- Verificar se a franquia existe\r\n    IF NOT EXISTS (SELECT 1 FROM public.franquias WHERE id = p_franquia_id) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Franquia não encontrada'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se já existe um usuário com o mesmo email\r\n    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'mensagem', 'Já existe um usuário com este email'\r\n        );\r\n    END IF;\r\n\r\n    -- Obter informações da franquia\r\n    SELECT nome, email \r\n    INTO v_franquia_nome, v_email\r\n    FROM public.franquias \r\n    WHERE id = p_franquia_id;\r\n\r\n    -- Se o nome do responsável não foi fornecido, usar o nome da franquia\r\n    IF p_nome IS NULL OR p_nome = '' THEN\r\n        p_nome := v_franquia_nome;\r\n    END IF;\r\n\r\n    -- Utilizar o email da franquia se não for fornecido\r\n    IF p_email IS NULL OR p_email = '' THEN\r\n        p_email := v_email;\r\n    END IF;\r\n\r\n    -- Criar o usuário\r\n    INSERT INTO auth.users (\r\n        email,\r\n        encrypted_password,\r\n        email_confirmed_at,\r\n        raw_app_meta_data,\r\n        raw_user_meta_data\r\n    ) VALUES (\r\n        p_email,\r\n        crypt(p_senha, gen_salt('bf')),\r\n        now(),\r\n        '{\"provider\":\"email\",\"providers\":[\"email\"],\"role\":\"franquia\"}'::jsonb,\r\n        jsonb_build_object('nome', p_nome)\r\n    )\r\n    RETURNING id INTO v_user_id;\r\n\r\n    -- Atualizar user_id na franquia (de forma segura)\r\n    BEGIN\r\n        UPDATE public.franquias\r\n        SET user_id = v_user_id\r\n        WHERE id = p_franquia_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        -- Se falhar ao atualizar franquia, ainda retornar sucesso na criação do usuário\r\n        RETURN jsonb_build_object(\r\n            'sucesso', true,\r\n            'mensagem', 'Usuário criado, mas não foi possível associá-lo à franquia',\r\n            'user_id', v_user_id,\r\n            'franquia_id', p_franquia_id\r\n        );\r\n    END;\r\n\r\n    RETURN jsonb_build_object(\r\n        'sucesso', true,\r\n        'mensagem', 'Usuário da franquia criado com sucesso',\r\n        'user_id', v_user_id,\r\n        'franquia_id', p_franquia_id\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'sucesso', false,\r\n        'mensagem', 'Erro ao criar usuário para franquia: ' || SQLERRM\r\n    );\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.importar_prazos_licitacoes()\n RETURNS SETOF prazos\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Inserir prazo de abertura para licitações que não têm\r\n    INSERT INTO public.prazos (\r\n        licitacao_id,\r\n        titulo,\r\n        tipo,\r\n        data_prazo,\r\n        observacoes\r\n    )\r\n    SELECT \r\n        l.id,\r\n        'Abertura da Licitação: ' || l.numero,\r\n        'ABERTURA'::tipo_prazo,\r\n        l.data_abertura,\r\n        'Prazo importado automaticamente'\r\n    FROM public.licitacoes l\r\n    WHERE NOT EXISTS (\r\n        SELECT 1 \r\n        FROM public.prazos p \r\n        WHERE p.licitacao_id = l.id \r\n        AND p.tipo = 'ABERTURA'\r\n    );\r\n\r\n    -- Retornar todos os prazos criados\r\n    RETURN QUERY\r\n    SELECT *\r\n    FROM public.prazos\r\n    WHERE created_at >= NOW() - INTERVAL '5 minutes'\r\n    ORDER BY data_prazo;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.excluir_franquia_com_usuario(p_franquia_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_franquia_record RECORD;\r\n    v_user_id UUID;\r\n    v_cliente_count INTEGER;\r\n    v_result JSONB;\r\nBEGIN\r\n    -- Inicia uma transação\r\n    BEGIN\r\n        -- Verificar se a franquia existe\r\n        SELECT id, user_id, nome INTO v_franquia_record FROM public.franquias WHERE id = p_franquia_id;\r\n        \r\n        IF NOT FOUND THEN\r\n            RETURN jsonb_build_object('success', false, 'error', 'Franquia não encontrada');\r\n        END IF;\r\n        \r\n        -- Verificar se há clientes vinculados\r\n        SELECT COUNT(*) INTO v_cliente_count FROM public.franquia_clientes WHERE franquia_id = p_franquia_id;\r\n        \r\n        IF v_cliente_count > 0 THEN\r\n            RETURN jsonb_build_object(\r\n                'success', false, \r\n                'error', 'Existem clientes vinculados a esta franquia. Remova-os antes de excluir a franquia.',\r\n                'cliente_count', v_cliente_count\r\n            );\r\n        END IF;\r\n        \r\n        -- Verificar se há outras dependências (como documentos, licitações, etc.)\r\n        -- Adicione verificações adicionais aqui se necessário\r\n        \r\n        -- Se há um usuário vinculado, vamos excluí-lo\r\n        IF v_franquia_record.user_id IS NOT NULL THEN\r\n            v_user_id := v_franquia_record.user_id;\r\n            \r\n            -- Verificar se o usuário existe\r\n            IF EXISTS (SELECT 1 FROM auth.users WHERE id = v_user_id) THEN\r\n                -- Opção 1: Excluir o usuário fisicamente (se tiver permissões suficientes)\r\n                -- DELETE FROM auth.users WHERE id = v_user_id;\r\n                \r\n                -- Opção 2: Desativar o usuário (soft delete)\r\n                UPDATE auth.users \r\n                SET \r\n                    email = 'deleted_' || email,\r\n                    encrypted_password = NULL,\r\n                    email_confirmed_at = NULL,\r\n                    last_sign_in_at = NULL,\r\n                    raw_app_meta_data = jsonb_set(\r\n                        COALESCE(raw_app_meta_data, '{}'::jsonb),\r\n                        '{deletedAt}',\r\n                        to_jsonb(NOW())\r\n                    ),\r\n                    raw_user_meta_data = jsonb_set(\r\n                        COALESCE(raw_user_meta_data, '{}'::jsonb),\r\n                        '{deletedAt}',\r\n                        to_jsonb(NOW())\r\n                    ),\r\n                    banned_until = '2100-01-01'::timestamptz,\r\n                    updated_at = NOW()\r\n                WHERE id = v_user_id;\r\n            END IF;\r\n        END IF;\r\n        \r\n        -- Agora podemos excluir a franquia com segurança\r\n        DELETE FROM public.franquias WHERE id = p_franquia_id;\r\n        \r\n        -- Se chegamos até aqui, tudo foi bem-sucedido\r\n        RETURN jsonb_build_object(\r\n            'success', true, \r\n            'message', 'Franquia e usuário excluídos com sucesso',\r\n            'franquia_nome', v_franquia_record.nome,\r\n            'user_id', v_user_id\r\n        );\r\n        \r\n    EXCEPTION WHEN OTHERS THEN\r\n        -- Em caso de erro, a transação é revertida automaticamente\r\n        RETURN jsonb_build_object('success', false, 'error', SQLERRM);\r\n    END;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.relatorio_clientes_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_count_total BIGINT;\r\n    v_result JSON;\r\nBEGIN\r\n    -- Log dos parâmetros recebidos para depuração\r\n    RAISE NOTICE 'Parâmetros recebidos: p_data_inicio=%, p_data_fim=%', \r\n                p_data_inicio, p_data_fim;\r\n    \r\n    -- Verificar se existem clientes na tabela\r\n    SELECT COUNT(*) INTO v_count_total FROM clientes;\r\n    RAISE NOTICE 'Total de clientes na tabela: %', v_count_total;\r\n    \r\n    -- Se não houver clientes, retornar valores padrão\r\n    IF v_count_total = 0 THEN\r\n        RAISE NOTICE 'Nenhum cliente encontrado na tabela.';\r\n        v_result := json_build_object(\r\n            'total_clientes', 0,\r\n            'clientes_ativos', 0,\r\n            'valor_total_licitacoes', 0,\r\n            'detalhes', '[]'::json\r\n        );\r\n        RETURN v_result;\r\n    END IF;\r\n\r\n    -- Calcular métricas e detalhes\r\n    WITH metricas_clientes AS (\r\n        SELECT \r\n            c.id,\r\n            c.razao_social,\r\n            c.cnpj,\r\n            COUNT(l.id) as total_licitacoes,\r\n            COUNT(*) FILTER (WHERE l.status = 'CONCLUIDA' AND l.foi_ganha = true) as licitacoes_ganhas,\r\n            COUNT(*) FILTER (WHERE l.status = 'EM_ANDAMENTO') as licitacoes_em_andamento,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.valor_final ELSE 0 END), 0) as valor_total_ganho,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.lucro_final ELSE 0 END), 0) as lucro_total\r\n        FROM clientes c\r\n        LEFT JOIN licitacoes l ON l.cliente_id = c.id\r\n            AND (p_data_inicio IS NULL OR l.data_abertura >= p_data_inicio)\r\n            AND (p_data_fim IS NULL OR l.data_abertura <= p_data_fim)\r\n        GROUP BY c.id, c.razao_social, c.cnpj\r\n    ),\r\n    agregados AS (\r\n        SELECT \r\n            COUNT(*)::BIGINT as total_clientes,\r\n            COUNT(*) FILTER (WHERE total_licitacoes > 0)::BIGINT as clientes_ativos,\r\n            COALESCE(SUM(valor_total_ganho), 0) as valor_total_licitacoes,\r\n            COALESCE(\r\n                json_agg(\r\n                    json_build_object(\r\n                        'id', id,\r\n                        'razao_social', razao_social,\r\n                        'cnpj', cnpj,\r\n                        'total_licitacoes', total_licitacoes,\r\n                        'licitacoes_ganhas', licitacoes_ganhas,\r\n                        'licitacoes_em_andamento', licitacoes_em_andamento,\r\n                        'valor_total_ganho', valor_total_ganho,\r\n                        'lucro_total', lucro_total\r\n                    )\r\n                    ORDER BY razao_social\r\n                ) FILTER (WHERE id IS NOT NULL),\r\n                '[]'::json\r\n            ) as detalhes\r\n        FROM metricas_clientes\r\n    )\r\n    SELECT json_build_object(\r\n        'total_clientes', total_clientes,\r\n        'clientes_ativos', clientes_ativos,\r\n        'valor_total_licitacoes', valor_total_licitacoes,\r\n        'detalhes', detalhes\r\n    ) INTO v_result\r\n    FROM agregados;\r\n    \r\n    RAISE NOTICE 'Resultado do relatório de clientes: %', v_result;\r\n    RETURN v_result;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.relatorio_desempenho_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_motivos_perda JSON;\r\n    v_evolucao_mensal JSON;\r\n    v_count_total BIGINT;\r\n    v_result JSON;\r\nBEGIN\r\n    -- Log dos parâmetros recebidos para depuração\r\n    RAISE NOTICE 'Parâmetros recebidos: p_data_inicio=%, p_data_fim=%', \r\n                p_data_inicio, p_data_fim;\r\n    \r\n    -- Verificar se existem licitações na tabela\r\n    SELECT COUNT(*) INTO v_count_total FROM licitacoes;\r\n    RAISE NOTICE 'Total de licitações na tabela: %', v_count_total;\r\n    \r\n    -- Se não houver licitações, retornar valores padrão\r\n    IF v_count_total = 0 THEN\r\n        RAISE NOTICE 'Nenhuma licitação encontrada na tabela.';\r\n        v_result := json_build_object(\r\n            'total_licitacoes', 0,\r\n            'taxa_sucesso', 0,\r\n            'valor_total_ganho', 0,\r\n            'lucro_total', 0,\r\n            'media_prazo_fechamento', 0,\r\n            'motivos_perda', '{}'::json,\r\n            'evolucao_mensal', '[]'::json\r\n        );\r\n        RETURN v_result;\r\n    END IF;\r\n\r\n    -- Calcular os motivos de perda\r\n    SELECT COALESCE(\r\n        json_object_agg(\r\n            COALESCE(motivo_perda, 'NÃO ESPECIFICADO'),\r\n            total_motivo\r\n        ),\r\n        '{}'::json\r\n    )\r\n    INTO v_motivos_perda\r\n    FROM (\r\n        SELECT motivo_perda, COUNT(*) as total_motivo\r\n        FROM licitacoes l\r\n        WHERE (p_data_inicio IS NULL OR l.data_abertura >= p_data_inicio)\r\n        AND (p_data_fim IS NULL OR l.data_abertura <= p_data_fim)\r\n        AND l.status = 'CONCLUIDA' \r\n        AND l.foi_ganha = false\r\n        GROUP BY l.motivo_perda\r\n    ) m;\r\n\r\n    -- Calcular a evolução mensal\r\n    SELECT COALESCE(\r\n        json_agg(\r\n            json_build_object(\r\n                'mes', e.mes,\r\n                'total_licitacoes', e.total_licitacoes,\r\n                'licitacoes_ganhas', e.licitacoes_ganhas,\r\n                'valor_total', e.valor_total,\r\n                'lucro_total', e.lucro_total\r\n            ) ORDER BY e.mes\r\n        ),\r\n        '[]'::json\r\n    )\r\n    INTO v_evolucao_mensal\r\n    FROM (\r\n        SELECT \r\n            TO_CHAR(l.data_abertura, 'YYYY-MM') as mes,\r\n            COUNT(*) as total_licitacoes,\r\n            COUNT(*) FILTER (WHERE l.status = 'CONCLUIDA' AND l.foi_ganha = true) as licitacoes_ganhas,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.valor_final ELSE 0 END), 0) as valor_total,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.lucro_final ELSE 0 END), 0) as lucro_total\r\n        FROM licitacoes l\r\n        WHERE (p_data_inicio IS NULL OR l.data_abertura >= p_data_inicio)\r\n        AND (p_data_fim IS NULL OR l.data_abertura <= p_data_fim)\r\n        GROUP BY TO_CHAR(l.data_abertura, 'YYYY-MM')\r\n    ) e;\r\n\r\n    -- Calcular métricas gerais\r\n    WITH metricas AS (\r\n        SELECT \r\n            COUNT(*) as total_licitacoes,\r\n            COUNT(*) FILTER (WHERE l.status = 'CONCLUIDA') as total_concluidas,\r\n            COUNT(*) FILTER (WHERE l.status = 'CONCLUIDA' AND l.foi_ganha = true) as total_ganhas,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.valor_final ELSE 0 END), 0) as valor_total_ganho,\r\n            COALESCE(SUM(CASE WHEN l.status = 'CONCLUIDA' AND l.foi_ganha = true THEN l.lucro_final ELSE 0 END), 0) as lucro_total,\r\n            COALESCE(AVG(EXTRACT(EPOCH FROM (l.data_fechamento - l.data_abertura))/86400.0) FILTER (WHERE l.status = 'CONCLUIDA'), 0) as media_prazo_fechamento\r\n        FROM licitacoes l\r\n        WHERE (p_data_inicio IS NULL OR l.data_abertura >= p_data_inicio)\r\n        AND (p_data_fim IS NULL OR l.data_abertura <= p_data_fim)\r\n    )\r\n    SELECT json_build_object(\r\n        'total_licitacoes', total_licitacoes,\r\n        'taxa_sucesso', CASE \r\n            WHEN total_concluidas > 0 \r\n            THEN (total_ganhas::DECIMAL / total_concluidas * 100)\r\n            ELSE 0\r\n        END,\r\n        'valor_total_ganho', valor_total_ganho,\r\n        'lucro_total', lucro_total,\r\n        'media_prazo_fechamento', media_prazo_fechamento,\r\n        'motivos_perda', v_motivos_perda,\r\n        'evolucao_mensal', v_evolucao_mensal\r\n    ) INTO v_result\r\n    FROM metricas;\r\n    \r\n    RAISE NOTICE 'Resultado do relatório de desempenho: %', v_result;\r\n    RETURN v_result;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.relatorio_licitacoes_v3(p_data_inicio timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_fim timestamp with time zone DEFAULT NULL::timestamp with time zone, p_status text DEFAULT NULL::text, p_cliente_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_status status_licitacao;\r\n    v_count_total BIGINT;\r\n    v_result JSON;\r\nBEGIN\r\n    -- Log dos parâmetros recebidos para depuração\r\n    RAISE NOTICE 'Parâmetros recebidos: p_data_inicio=%, p_data_fim=%, p_status=%, p_cliente_id=%', \r\n                p_data_inicio, p_data_fim, p_status, p_cliente_id;\r\n    \r\n    -- Converter p_status para status_licitacao se não for NULL\r\n    IF p_status IS NOT NULL AND p_status != '' THEN\r\n        BEGIN\r\n            v_status := p_status::status_licitacao;\r\n        EXCEPTION WHEN OTHERS THEN\r\n            RAISE NOTICE 'Erro ao converter status: %. Usando NULL.', SQLERRM;\r\n            v_status := NULL;\r\n        END;\r\n    END IF;\r\n    \r\n    -- Verificar se existem licitações na tabela\r\n    SELECT COUNT(*) INTO v_count_total FROM licitacoes;\r\n    RAISE NOTICE 'Total de licitações na tabela: %', v_count_total;\r\n    \r\n    -- Se não houver licitações, retornar valores padrão\r\n    IF v_count_total = 0 THEN\r\n        RAISE NOTICE 'Nenhuma licitação encontrada na tabela.';\r\n        v_result := json_build_object(\r\n            'total_licitacoes', 0,\r\n            'licitacoes_ganhas', 0,\r\n            'licitacoes_perdidas', 0,\r\n            'licitacoes_em_andamento', 0,\r\n            'valor_total_ganho', 0,\r\n            'lucro_total', 0,\r\n            'taxa_sucesso', 0,\r\n            'detalhes', '[]'::json\r\n        );\r\n        RETURN v_result;\r\n    END IF;\r\n\r\n    -- Calcular métricas e detalhes\r\n    WITH licitacoes_filtradas AS (\r\n        SELECT l.*,\r\n               c.razao_social as cliente_razao_social,\r\n               c.cnpj as cliente_cnpj\r\n        FROM licitacoes l\r\n        LEFT JOIN clientes c ON c.id = l.cliente_id\r\n        WHERE (p_data_inicio IS NULL OR l.data_abertura >= p_data_inicio)\r\n        AND (p_data_fim IS NULL OR l.data_abertura <= p_data_fim)\r\n        AND (v_status IS NULL OR l.status = v_status)\r\n        AND (p_cliente_id IS NULL OR l.cliente_id = p_cliente_id)\r\n    ),\r\n    metricas AS (\r\n        SELECT \r\n            COUNT(*) as total_licitacoes,\r\n            COUNT(*) FILTER (WHERE status = 'CONCLUIDA' AND foi_ganha = true) as licitacoes_ganhas,\r\n            COUNT(*) FILTER (WHERE status = 'CONCLUIDA' AND foi_ganha = false) as licitacoes_perdidas,\r\n            COUNT(*) FILTER (WHERE status = 'EM_ANDAMENTO') as licitacoes_em_andamento,\r\n            COALESCE(SUM(CASE WHEN status = 'CONCLUIDA' AND foi_ganha = true THEN valor_final ELSE 0 END), 0) as valor_total_ganho,\r\n            COALESCE(SUM(CASE WHEN status = 'CONCLUIDA' AND foi_ganha = true THEN lucro_final ELSE 0 END), 0) as lucro_total,\r\n            CASE \r\n                WHEN COUNT(*) FILTER (WHERE status = 'CONCLUIDA') > 0 \r\n                THEN (COUNT(*) FILTER (WHERE status = 'CONCLUIDA' AND foi_ganha = true)::DECIMAL / \r\n                     COUNT(*) FILTER (WHERE status = 'CONCLUIDA')) * 100\r\n                ELSE 0\r\n            END as taxa_sucesso,\r\n            COALESCE(\r\n                json_agg(\r\n                    json_build_object(\r\n                        'id', id,\r\n                        'numero', numero,\r\n                        'orgao', orgao,\r\n                        'cliente_razao_social', cliente_razao_social,\r\n                        'cliente_cnpj', cliente_cnpj,\r\n                        'modalidade', modalidade,\r\n                        'valor_estimado', valor_estimado,\r\n                        'valor_final', valor_final,\r\n                        'lucro_estimado', lucro_estimado,\r\n                        'lucro_final', lucro_final,\r\n                        'foi_ganha', foi_ganha,\r\n                        'status', status,\r\n                        'data_abertura', data_abertura,\r\n                        'data_fechamento', data_fechamento\r\n                    )\r\n                    ORDER BY data_abertura DESC\r\n                ) FILTER (WHERE id IS NOT NULL),\r\n                '[]'::json\r\n            ) as detalhes\r\n        FROM licitacoes_filtradas\r\n    )\r\n    SELECT json_build_object(\r\n        'total_licitacoes', total_licitacoes,\r\n        'licitacoes_ganhas', licitacoes_ganhas,\r\n        'licitacoes_perdidas', licitacoes_perdidas,\r\n        'licitacoes_em_andamento', licitacoes_em_andamento,\r\n        'valor_total_ganho', valor_total_ganho,\r\n        'lucro_total', lucro_total,\r\n        'taxa_sucesso', taxa_sucesso,\r\n        'detalhes', detalhes\r\n    ) INTO v_result\r\n    FROM metricas;\r\n    \r\n    RAISE NOTICE 'Resultado do relatório de licitações: %', v_result;\r\n    RETURN v_result;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.testar_processamento_requisitos(p_licitacao_id uuid)\n RETURNS SETOF requisito_result\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_texto_exemplo TEXT;\r\nBEGIN\r\n    -- Verificar se a licitação existe\r\n    IF NOT EXISTS (SELECT 1 FROM licitacoes WHERE id = p_licitacao_id) THEN\r\n        RAISE EXCEPTION 'Licitação não encontrada';\r\n    END IF;\r\n    \r\n    -- Texto de exemplo com requisitos de documentação\r\n    v_texto_exemplo := '\r\nDOCUMENTOS DE HABILITAÇÃO\r\n\r\nHabilitação Jurídica:\r\n1. Registro comercial, no caso de empresa individual;\r\n2. Ato constitutivo, estatuto ou contrato social em vigor, devidamente registrado, em se tratando de sociedades comerciais;\r\n3. Documentos de eleição dos atuais administradores, tratando-se de sociedades por ações;\r\n4. Decreto de autorização e ato de registro, tratando-se de empresa ou sociedade estrangeira em funcionamento no País.\r\n\r\nRegularidade Fiscal:\r\n5. Prova de inscrição no Cadastro Nacional de Pessoas Jurídicas (CNPJ);\r\n6. Certidão Negativa de Débitos Federais, com prazo de validade de 30 dias;\r\n7. Certidão Negativa de Débitos Estaduais;\r\n8. Certidão Negativa de Débitos Municipais;\r\n9. Certificado de Regularidade do FGTS - CRF;\r\n10. Certidão Negativa de Débitos Trabalhistas (CNDT).\r\n\r\nQualificação Técnica:\r\n11. Registro ou inscrição na entidade profissional competente;\r\n12. Comprovação de aptidão para desempenho de atividade pertinente e compatível com o objeto da licitação;\r\n13. Atestado(s) de capacidade técnica, fornecido(s) por pessoa jurídica de direito público ou privado.\r\n\r\nQualificação Econômico-Financeira:\r\n14. Balanço patrimonial e demonstrações contábeis do último exercício social;\r\n15. Certidão negativa de falência ou concordata expedida pelo distribuidor da sede da pessoa jurídica.\r\n\r\nDeclarações:\r\n16. Declaração de que não emprega menor de 18 anos em trabalho noturno, perigoso ou insalubre;\r\n17. Declaração de inexistência de fato superveniente impeditivo da habilitação.\r\n\r\nPROPOSTA COMERCIAL\r\nA proposta deverá conter:\r\n- Preço unitário e total;\r\n- Prazo de validade da proposta;\r\n- Prazo de entrega.\r\n    ';\r\n    \r\n    -- Limpar requisitos existentes para esta licitação\r\n    DELETE FROM requisitos_documentacao WHERE licitacao_id = p_licitacao_id;\r\n    \r\n    -- Processar o texto de exemplo\r\n    RETURN QUERY\r\n    SELECT * FROM processar_requisitos_edital(v_texto_exemplo, p_licitacao_id);\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_e_criar_usuario_franquia(p_franquia_id uuid, p_email character varying, p_senha character varying, p_nome character varying DEFAULT NULL::character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_existe_usuario BOOLEAN;\r\n    v_resultado jsonb;\r\nBEGIN\r\n    -- Validar parâmetros\r\n    IF p_franquia_id IS NULL THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'codigo', 'FRANQUIA_ID_NULO',\r\n            'mensagem', 'ID da franquia não pode ser nulo'\r\n        );\r\n    END IF;\r\n\r\n    IF p_email IS NULL OR p_email = '' THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'codigo', 'EMAIL_INVALIDO',\r\n            'mensagem', 'Email não pode ser nulo ou vazio'\r\n        );\r\n    END IF;\r\n\r\n    IF p_senha IS NULL OR length(p_senha) < 6 THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'codigo', 'SENHA_INVALIDA',\r\n            'mensagem', 'Senha deve ter pelo menos 6 caracteres'\r\n        );\r\n    END IF;\r\n\r\n    -- Verificar se o usuário já existe\r\n    BEGIN\r\n        SELECT check_user_exists(p_email) INTO v_existe_usuario;\r\n        \r\n        IF v_existe_usuario THEN\r\n            RETURN jsonb_build_object(\r\n                'sucesso', false,\r\n                'codigo', 'EMAIL_JA_EXISTE',\r\n                'mensagem', 'Já existe um usuário com este email: ' || p_email\r\n            );\r\n        END IF;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RAISE WARNING 'Erro ao verificar existência de usuário: %', SQLERRM;\r\n        -- Verificar diretamente na tabela de usuários\r\n        BEGIN\r\n            IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN\r\n                RETURN jsonb_build_object(\r\n                    'sucesso', false,\r\n                    'codigo', 'EMAIL_JA_EXISTE',\r\n                    'mensagem', 'Já existe um usuário com este email: ' || p_email\r\n                );\r\n            END IF;\r\n        EXCEPTION WHEN OTHERS THEN\r\n            RAISE WARNING 'Erro ao verificar existência de usuário diretamente: %', SQLERRM;\r\n            -- Continuar mesmo com erro de verificação, a tentativa de inserção capturará duplicatas\r\n        END;\r\n    END;\r\n\r\n    -- Tentar criar o usuário usando a função existente\r\n    BEGIN\r\n        SELECT criar_usuario_franquia_v2(p_franquia_id, p_email, p_senha, p_nome) INTO v_resultado;\r\n        RETURN v_resultado;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'sucesso', false,\r\n            'codigo', 'ERRO_CRIAR_USUARIO',\r\n            'mensagem', 'Erro ao criar usuário: ' || SQLERRM,\r\n            'detalhes', SQLERRM\r\n        );\r\n    END;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.verificar_integridade_banco()\n RETURNS TABLE(tabela text, status text, mensagem text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    -- Verificar schema auth\r\n    BEGIN\r\n        PERFORM 1 FROM pg_namespace WHERE nspname = 'auth';\r\n        RETURN QUERY SELECT 'auth.schema'::TEXT, 'OK'::TEXT, 'Schema auth existe'::TEXT;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN QUERY SELECT 'auth.schema'::TEXT, 'ERRO'::TEXT, SQLERRM::TEXT;\r\n    END;\r\n    \r\n    -- Verificar tabela users\r\n    BEGIN\r\n        PERFORM 1 FROM auth.users LIMIT 1;\r\n        RETURN QUERY SELECT 'auth.users'::TEXT, 'OK'::TEXT, 'Tabela users acessível'::TEXT;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN QUERY SELECT 'auth.users'::TEXT, 'ERRO'::TEXT, SQLERRM::TEXT;\r\n    END;\r\n    \r\n    -- Verificar função de login\r\n    BEGIN\r\n        -- Não executamos a função, apenas verificamos se ela existe\r\n        RETURN QUERY SELECT 'auth.email_login'::TEXT, 'OK'::TEXT, 'Função de login existe'::TEXT \r\n        FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid \r\n        WHERE n.nspname = 'auth' AND p.proname = 'email_login' \r\n        LIMIT 1;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN QUERY SELECT 'auth.email_login'::TEXT, 'ERRO'::TEXT, SQLERRM::TEXT;\r\n    END;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION public.vincular_cliente_franquia(p_cliente_id uuid, p_franquia_id uuid, p_matriz_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Verificar se o cliente existe\r\n  IF NOT EXISTS (SELECT 1 FROM clientes WHERE id = p_cliente_id) THEN\r\n    RAISE EXCEPTION 'Cliente não encontrado';\r\n  END IF;\r\n  \r\n  -- Verificar se a franquia existe (se fornecida)\r\n  IF p_franquia_id IS NOT NULL AND NOT EXISTS (SELECT 1 FROM franquias WHERE id = p_franquia_id) THEN\r\n    RAISE EXCEPTION 'Franquia não encontrada';\r\n  END IF;\r\n  \r\n  -- Verificar se o usuário matriz existe\r\n  IF NOT EXISTS (SELECT 1 FROM perfis_usuario WHERE user_id = p_matriz_id AND tipo = 'MATRIZ') THEN\r\n    RAISE EXCEPTION 'Usuário matriz não encontrado';\r\n  END IF;\r\n  \r\n  -- Verificar se o cliente pertence à matriz\r\n  IF NOT EXISTS (SELECT 1 FROM clientes WHERE id = p_cliente_id AND matriz_id = p_matriz_id) THEN\r\n    RAISE EXCEPTION 'Cliente não pertence a esta matriz';\r\n  END IF;\r\n  \r\n  -- Atualizar a vinculação do cliente\r\n  UPDATE clientes\r\n  SET franquia_id = p_franquia_id,\r\n      data_vinculo = NOW(),\r\n      updated_at = NOW()\r\n  WHERE id = p_cliente_id;\r\n  \r\n  RETURN TRUE;\r\nEND;\r\n$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n\n\nCREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n\n\nCREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n\n\nCREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n\n\nCREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n\n\nCREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' then\n      v_sort_order = 'desc';\n    else\n      v_sort_order = 'asc';\n  end case;\n\n  v_order_by = v_order_by || ' ' || v_sort_order;\n\n  return query execute\n    'with folders as (\n       select path_tokens[$1] as folder\n       from storage.objects\n         where objects.name ilike $2 || $3 || ''%''\n           and bucket_id = $4\n           and array_length(objects.path_tokens, 1) <> $1\n       group by folder\n       order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n\n\nCREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n\n\nCREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n\n\nCREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_decrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION pgsodium.crypto_aead_det_encrypt(message bytea, additional bytea, key_uuid uuid, nonce bytea)\n RETURNS bytea\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  $function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n\n\nCREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n\n\nCREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n\n\nCREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n\n\nCREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n\n\nCREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n\n\nCREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n\n\nCREATE TRIGGER \"update_documentos_cliente_updated_at\" BEFORE UPDATE ON \"documentos_cliente\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_clientes_updated_at\" BEFORE UPDATE ON \"clientes\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_documentos_licitacao_updated_at\" BEFORE UPDATE ON \"documentos_licitacao\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_licitacoes_updated_at\" BEFORE UPDATE ON \"licitacoes\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_prazos_updated_at\" BEFORE UPDATE ON \"prazos\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_requisitos_documentacao_updated_at\" BEFORE UPDATE ON \"requisitos_documentacao\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"update_tipos_documentos_updated_at\" BEFORE UPDATE ON \"tipos_documentos\" FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\nCREATE TRIGGER \"tr_check_filters\" BEFORE INSERT ON \"subscription\" FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();\n\nCREATE TRIGGER \"tr_check_filters\" BEFORE UPDATE ON \"subscription\" FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();\n\nCREATE TRIGGER \"update_objects_updated_at\" BEFORE UPDATE ON \"objects\" FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();\n\nCREATE TRIGGER \"secrets_encrypt_secret_trigger_secret\" BEFORE INSERT ON \"secrets\" FOR EACH ROW EXECUTE FUNCTION vault.secrets_encrypt_secret_secret();\n\nCREATE TRIGGER \"secrets_encrypt_secret_trigger_secret\" BEFORE UPDATE ON \"secrets\" FOR EACH ROW EXECUTE FUNCTION vault.secrets_encrypt_secret_secret();\n\nCREATE TRIGGER \"key_encrypt_secret_trigger_raw_key\" BEFORE INSERT ON \"key\" FOR EACH ROW EXECUTE FUNCTION pgsodium.key_encrypt_secret_raw_key();\n\nCREATE TRIGGER \"key_encrypt_secret_trigger_raw_key\" BEFORE UPDATE ON \"key\" FOR EACH ROW EXECUTE FUNCTION pgsodium.key_encrypt_secret_raw_key();\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"fk_prazos_licitacao\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"prazos_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"documentos_cliente_cliente_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"documentos_cliente_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"documentos_cliente_tipo_documento_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"franquias_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"franquias_user_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"uk_franquias_cnpj\" UNIQUE;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"uk_franquias_user_id\" UNIQUE;\n\nALTER TABLE \"public\".\"health_check\" ADD CONSTRAINT \"health_check_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"licitacoes_cliente_cliente_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"licitacoes_cliente_franquia_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"licitacoes_cliente_licitacao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"licitacoes_cliente_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"uk_licitacoes_cliente\" UNIQUE;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"permissoes_tipo_usuario_permissao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"permissoes_tipo_usuario_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"uk_permissoes_tipo_usuario\" UNIQUE;\n\nALTER TABLE \"public\".\"requisitos_documentacao\" ADD CONSTRAINT \"requisitos_documentacao_licitacao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"requisitos_documentacao\" ADD CONSTRAINT \"requisitos_documentacao_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"clientes_cnpj_key\" UNIQUE;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"clientes_franquia_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"clientes_matriz_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"clientes_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"clientes_user_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"licitacoes_cliente_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"licitacoes_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"uk_numero_orgao\" UNIQUE;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"documentos_licitacao_licitacao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"documentos_licitacao_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"documentos_licitacao_tipo_documento_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"perfis_usuario_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"perfis_usuario_user_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"uk_perfis_usuario_user_id\" UNIQUE;\n\nALTER TABLE \"public\".\"permissoes\" ADD CONSTRAINT \"permissoes_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"permissoes\" ADD CONSTRAINT \"uk_permissoes_codigo\" UNIQUE;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"permissoes_cliente_cliente_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"permissoes_cliente_permissao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"permissoes_cliente_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"uk_permissoes_cliente\" UNIQUE;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"permissoes_franquia_franquia_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"permissoes_franquia_permissao_id_fkey\" FOREIGN KEY;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"permissoes_franquia_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"uk_permissoes_franquia\" UNIQUE;\n\nALTER TABLE \"public\".\"tipos_documentos\" ADD CONSTRAINT \"tipos_documentos_nome_key\" UNIQUE;\n\nALTER TABLE \"public\".\"tipos_documentos\" ADD CONSTRAINT \"tipos_documentos_pkey\" PRIMARY KEY;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"2200_29744_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"2200_29744_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"2200_29744_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"2200_29744_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"prazos\" ADD CONSTRAINT \"2200_29744_5_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"2200_29932_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"2200_29932_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"2200_29932_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"2200_29932_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_cliente\" ADD CONSTRAINT \"2200_29932_5_not_null\" CHECK;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"2200_29948_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"franquias\" ADD CONSTRAINT \"2200_29948_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"health_check\" ADD CONSTRAINT \"2200_29958_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"2200_29967_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"2200_29967_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes_cliente\" ADD CONSTRAINT \"2200_29967_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"2200_30006_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"2200_30006_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_tipo_usuario\" ADD CONSTRAINT \"2200_30006_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"requisitos_documentacao\" ADD CONSTRAINT \"2200_29705_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"requisitos_documentacao\" ADD CONSTRAINT \"2200_29705_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"requisitos_documentacao\" ADD CONSTRAINT \"2200_29705_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"2200_29718_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"2200_29718_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"2200_29718_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"clientes\" ADD CONSTRAINT \"2200_29718_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_5_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_6_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_9_not_null\" CHECK;\n\nALTER TABLE \"public\".\"licitacoes\" ADD CONSTRAINT \"2200_29732_11_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"2200_29940_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"2200_29940_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"2200_29940_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"2200_29940_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"documentos_licitacao\" ADD CONSTRAINT \"2200_29940_5_not_null\" CHECK;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"2200_29977_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"2200_29977_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"perfis_usuario\" ADD CONSTRAINT \"2200_29977_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes\" ADD CONSTRAINT \"2200_29984_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes\" ADD CONSTRAINT \"2200_29984_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes\" ADD CONSTRAINT \"2200_29984_4_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"2200_29992_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"2200_29992_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_cliente\" ADD CONSTRAINT \"2200_29992_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"2200_29999_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"2200_29999_2_not_null\" CHECK;\n\nALTER TABLE \"public\".\"permissoes_franquia\" ADD CONSTRAINT \"2200_29999_3_not_null\" CHECK;\n\nALTER TABLE \"public\".\"tipos_documentos\" ADD CONSTRAINT \"2200_30018_1_not_null\" CHECK;\n\nALTER TABLE \"public\".\"tipos_documentos\" ADD CONSTRAINT \"2200_30018_2_not_null\" CHECK;"
  }
]